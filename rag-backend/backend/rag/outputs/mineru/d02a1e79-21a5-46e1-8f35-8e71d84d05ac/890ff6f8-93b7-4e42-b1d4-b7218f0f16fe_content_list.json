[
    {
        "type": "text",
        "text": "A ConvNet for the 2020s ",
        "text_level": 1,
        "bbox": [
            364,
            131,
            607,
            151
        ],
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "Zhuang Liu1,2\\* Hanzi Mao1 Chao-Yuan Wu1 Christoph Feichtenhofer1Trevor Darrell²Saining Xie1† 1Facebook AI Research (FAIR)²UC Berkeley Code: https://github.com/facebookresearch/ConvNeXt ",
        "bbox": [
            75,
            179,
            919,
            242
        ],
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "Abstract ",
        "text_level": 1,
        "bbox": [
            236,
            257,
            310,
            275
        ],
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "The“Roaring 2Os”of visual recognition began with the introduction of Vision Transformers (ViTs),which quickly superseded ConvNets as the state-of-the-art image classificationmodel.A vanilla ViT,on theotherhand,facesdifficulties when applied to general computer vision tasks such as object detection and semantic segmentation.It is the hierarchical Transformers(e.g.,Swin Transformers) that reintroduced several ConvNet priors,making Transformers practically viable asa generic vision backbone and demonstrating remarkable performance on a wide variety of vision tasks. However, the effectiveness of such hybrid approaches is still largely credited to the intrinsic superiority of Transformers,rather than the inherent inductive biases of convolutions.In this work,we reexamine the design spaces and test the limits of what a pure ConvNet can achieve.We gradually “modernize” a standard ResNet toward the design of a vision Transformer, and discover several key components that contribute to the performance difference along the way. The outcome of this exploration is a family of pure ConvNet models dubbed ConvNeXt. Constructed entirely from standard ConvNetmodules, ConvNeXts compete favorably with Transformers in terms of accuracy and scalability, achieving $8 7 . 8 \\%$ ImageNet top-1 accuracy and outperforming Swin Transformers on COCO detection and ADE2OK segmentation,while maintaining the simplicity and effciencyof standard ConvNets. ",
        "bbox": [
            78,
            291,
            470,
            667
        ],
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "1. Introduction ",
        "text_level": 1,
        "bbox": [
            80,
            699,
            205,
            717
        ],
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "Looking back at the 2O1Os, the decade was marked by the monumental progress and impact of deep learning.The primary driver was the renaissance of neural networks, particularly convolutional neural networks (ConvNets). Through the decade, the field of visual recognition successfully shifted from engineering features to designing (ConvNet) architectures.Although the invention of back-propagationtrained ConvNets dates all the way back to the 1980s [42], it was not until late 2O12 that we saw its true potential for visual feature learning. The introduction of AlexNet [40] precipitated the “ImageNet moment” [59], ushering in a new era of computer vision. The field has since evolved at a rapid speed. Representative ConvNets like VGGNet [64], Inceptions [68], ResNe(X)t [28,87], DenseNet [36], MobileNet [34], EfficientNet [71] and RegNet [54] focused on different aspects of accuracy, efficiency and scalability, and popularized many useful design principles. ",
        "bbox": [
            80,
            727,
            468,
            861
        ],
        "page_idx": 0
    },
    {
        "type": "image",
        "img_path": "images/e93daa4c71ad33c4b20005ffcf8f33698b6bbf91471a5b39cbed4358a909a13f.jpg",
        "image_caption": [
            "Figure 1.ImageNet-1K classification results for·ConvNets and $\\cdot$ vision Transformers.Each bubble's area is proportional to FLOPs of a variant in a model family. ImageNet-1K/22K models here take $2 2 4 ^ { 2 } / 3 8 4 ^ { 2 }$ images respectively. ResNet and ViT results were obtained with improved training procedures over the original papers. We demonstrate thata standard ConvNet model can achieve the same level of scalability as hierarchical vision Transformers while being much simpler in design. "
        ],
        "image_footnote": [],
        "bbox": [
            501,
            258,
            888,
            452
        ],
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "",
        "bbox": [
            503,
            582,
            892,
            703
        ],
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "The full dominance of ConvNets in computer vision was not a coincidence: in many application scenarios,a “sliding window” strategy is intrinsic to visual processing, particularly when working with high-resolution images. ConvNets have several built-in inductive biases that make them wellsuited to a wide variety of computer vision applications.The most important one is translation equivariance,which is a desirable property for tasks like objection detection. ConvNets are also inherently efficient due to the fact that when used in a sliding-window manner, the computations are shared [62]. For many decades, this has been the default use of ConvNets, generally on limited object categories such as digits [43], faces [58,76] and pedestrians [19,63]. Entering the 2010s, the region-based detectors [23,24,27,57] further elevated ConvNets to the position of being the fundamental building block in a visual recognition system. ",
        "bbox": [
            503,
            704,
            892,
            900
        ],
        "page_idx": 0
    },
    {
        "type": "discarded",
        "text": "\\*Work done during an internship at Facebook AI Research. + Corresponding author. ",
        "bbox": [
            98,
            875,
            406,
            900
        ],
        "page_idx": 0
    },
    {
        "type": "discarded",
        "text": "",
        "bbox": [
            24,
            267,
            58,
            699
        ],
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "",
        "bbox": [
            78,
            92,
            467,
            136
        ],
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "Around the same time, the odyssey of neural network design for natural language processing (NLP) took a very different path,as the Transformers replaced recurrent neural networks to become the dominant backbone architecture. Despite the disparity in the task of interest between language and vision domains,the two streams surprisingly converged in the year 2O2O,as the introduction of Vision Transformers (ViT) completely altered the landscape of network architecture design.Except for the initial “patchify”layer,which splits an image into a sequence of patches,ViT introduces no image-specific inductive bias and makes minimal changes to the original NLP Transformers. One primary focus of ViT is on the scaling behavior: with the help of larger model and dataset sizes,Transformers can outperform standard ResNets by a significant margin. Those results on image classification tasks are inspiring,but computer vision is not limited to image classification. As discussed previously, solutions to numerous computer vision tasks in the past decade depended significantly on a sliding-window, fullyconvolutional paradigm.Without the ConvNet inductive biases,a vanilla ViT model faces many challenges in being adopted as a generic vision backbone. The biggest challenge is ViT's global attention design, which has a quadratic complexity with respect to the input size.This might be acceptable for ImageNet classification, but quickly becomes intractable with higher-resolution inputs. ",
        "bbox": [
            80,
            140,
            467,
            531
        ],
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "Hierarchical Transformers employ a hybrid approach to bridge this gap. For example, the “sliding window” strategy (e.g.attention within local windows) was reintroduced to Transformers,allowing them to behave more similarly to ConvNets. Swin Transformer [45] is a milestone work in this direction,demonstrating for the first time that Transformers can be adopted as a generic vision backbone and achieve state-of-the-art performance across a range of computer vision tasks beyond image classification.Swin Transformer's success and rapid adoption also revealed one thing: the essence of convolution is not becoming irrelevant; rather, it remains much desired and has never faded. ",
        "bbox": [
            80,
            535,
            467,
            715
        ],
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "Under this perspective,many of the advancements of Transformers for computer vision have been aimed at bringing back convolutions. These attempts,however, come at a cost: a naive implementation of sliding window selfattention can be expensive [55]; with advanced approaches such as cyclic shifting [45], the speed can be optimized but the system becomes more sophisticated in design. On the otherhand,it is almost ironic that a ConvNet already satisfies many of those desired properties,albeit in a straightforward, no-frills way. The only reason ConvNets appear to be losing steam is that (hierarchical) Transformers surpass them in many vision tasks,and the performance difference is usually attributed to the superior scaling behavior of Transformers, with multi-head self-attention being the key component. ",
        "bbox": [
            80,
            719,
            468,
            900
        ],
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "",
        "bbox": [
            503,
            92,
            892,
            121
        ],
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "Unlike ConvNets,which have progressively improved over the last decade,the adoption of Vision Transformers was a step change. In recent literature,system-level comparisons (e.g.a Swin Transformer vs.a ResNet) are usually adopted when comparing the two. ConvNets and hierarchical vision Transformers become different and similar at the same time: they are both equipped with similar inductive biases,but differ significantly in the training procedure and macro/micro-level architecture design.In this work, we investigate the architectural distinctions between ConvNets and Transformers and try to identify the confounding variables when comparing the network performance.Our research is intended to bridge the gap between the pre-ViT and post-ViT eras for ConvNets,as well as to test the limits of what a pure ConvNet can achieve. ",
        "bbox": [
            503,
            122,
            892,
            347
        ],
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "To do this, we start with a standard ResNet (e.g. ResNet50) trained with an improved procedure. We gradually “modernize\" the architecture to the construction of a hierarchical vision Transformer (e.g. Swin-T). Our exploration is directed by a key question: How do design decisions in Transformers impact ConvNets' performance? We discover several key components that contribute to the performance difference along the way. As a result, we propose a family of pure ConvNets dubbed ConvNeXt.We evaluate ConvNeXts on a variety of vision tasks such as ImageNet classification [17], object detection/segmentation on COCO [44], and semantic segmentation on ADE2OK [92]. Surprisingly, ConvNeXts, constructed entirely from standard ConvNet modules,compete favorably with Transformers in terms of accuracy, scalability and robustness across all major benchmarks. ConvNeXt maintains the efficiency of standard ConvNets,and the fully-convolutional nature for both training and testing makes it extremely simple to implement. ",
        "bbox": [
            503,
            348,
            892,
            618
        ],
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "We hope the new observations and discussions can challenge some common beliefs and encourage people to rethink the importance of convolutions in computer vision. ",
        "bbox": [
            501,
            621,
            892,
            665
        ],
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "2. Modernizing a ConvNet: a Roadmap ",
        "text_level": 1,
        "bbox": [
            503,
            679,
            833,
            695
        ],
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "In this section, we provide a trajectory going from a ResNet to a ConvNet that bears a resemblance to Transformers.We consider two model sizes in terms of FLOPs,one is the ResNet-5O/Swin-Tregime with FLOPs around $4 . 5 \\times 1 0 ^ { 9 }$ and the other being ResNet-2OO / Swin-B regime which has FLOPs around $1 5 . 0 \\times 1 0 ^ { 9 }$ . For simplicity, we will present the results with the ResNet-50 / Swin-T complexity models. The conclusions for higher capacity models are consistent and results can be found in Appendix C. ",
        "bbox": [
            503,
            704,
            892,
            839
        ],
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "At a high level, our explorations are directed to investigate and follow different levels of designs from a Swin Transformer while maintaining the network's simplicity as a standard ConvNet. The roadmap of our exploration is as follows. Our starting point is a ResNet-5O model. We frst train it with similar training techniques used to train vision Transformers and obtain much improved results compared to the original ResNet-5O.This will be our baseline.We then study a series of design decisions which we summarized as1) macro design,2)ResNeXt,3) inverted bottleneck,4) large kernel size,and 5) various layer-wise micro designs. In Figure 2,we show the procedure and the results we are able to achieve with each step of the “network modernization”. Since network complexity is closely correlated with the final performance,the FLOPs are roughly controlled over the course of the exploration,though at intermediate steps the FLOPs might be higher or lower than the reference models. All models are trained and evaluated on ImageNet-1K. ",
        "bbox": [
            503,
            840,
            892,
            900
        ],
        "page_idx": 1
    },
    {
        "type": "image",
        "img_path": "images/196689084bdd09d6b8dee7e1f27180defce5048f4dad54ef0a1972033fbfe52e.jpg",
        "image_caption": [
            "Figure 2. We modernize a standard ConvNet (ResNet) towards the design of a hierarchical vision Transformer (Swin),without introducing any attention-based modules.The foreground bars are model accuracies in the ResNet-5O/Swin-TFLOP regime; results for the ResNet-2OO/Swin-B regime are shown with the gray bars.A hatched bar means the modification is not adopted.Detailed results for both regimes are in the appendix.Many Transformer architectural choices can be incorporated ina ConvNet,and they lead to increasingly better performance.In the end,our pure ConvNet model, named ConvNeXt,can outperform the Swin Transformer. "
        ],
        "image_footnote": [],
        "bbox": [
            86,
            90,
            436,
            464
        ],
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "",
        "bbox": [
            80,
            619,
            468,
            829
        ],
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "2.1. Training Techniques ",
        "text_level": 1,
        "bbox": [
            80,
            844,
            269,
            861
        ],
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "Apart from the design of the network architecture, the training procedure also affects the ultimate performance. Not only did vision Transformers bring a new set of modules and architectural design decisions, but they also introduced different training techniques (e.g. AdamW optimizer) to vision. This pertains mostly to the optimization strategy and associated hyper-parameter settings. Thus,the first step of our exploration is to train a baseline model with the vision Transformer training procedure, in this case,ResNet50/200.Recent studies [7,81] demonstrate that a set of modern training techniques can significantly enhance the performance of a simple ResNet-5O model. In our study, we use a training recipe that is close to DeiT's [73] and Swin Transformer's [45]. The training is extended to 300 epochs from the original 9O epochs for ResNets.We use the AdamW optimizer [46], data augmentation techniques such as Mixup [9O], Cutmix [89], RandAugment [14], Random Erasing [91],and regularization schemes including Stochastic Depth [36] and Label Smoothing 69]. The complete set of hyper-parameters we use can be found in Appendix A.1. By itself, this enhanced training recipe increased the performance of the ResNet-5O model from $7 6 . 1 \\%$ [1] to $7 8 . 8 \\%$ $( + 2 . 7 \\% )$ ,implying that a significant portion of the performance difference between traditional ConvNets and vision Transformers may be due to the training techniques.We will use this fixed training recipe with the same hyperparameters throughout the “modernization” process.Each reported accuracy on the ResNet-5O regime is an average obtained from training with three different random seeds. ",
        "bbox": [
            80,
            871,
            467,
            900
        ],
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "",
        "bbox": [
            503,
            92,
            890,
            497
        ],
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "2.2. Macro Design ",
        "text_level": 1,
        "bbox": [
            503,
            510,
            642,
            525
        ],
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "We now analyze Swin Transformers’macro network design. Swin Transformers follow ConvNets [28,65] to use a multi-stage design,where each stage has a different feature map resolution. There are two interesting design considerations: the stage compute ratio,and the “stem cell” structure. ",
        "bbox": [
            503,
            534,
            892,
            608
        ],
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "Changing stage compute ratio. The original design of the computation distribution across stages in ResNet was largely empirical. The heavy “res4” stage was meant to be compatible with downstream tasks like object detection, where a detector head operates on the $1 4 \\times 1 4$ feature plane. Swin-T, on the other hand, followed the same principle but with a slightly different stage compute ratio of 1:1:3:1. For larger Swin Transformers, the ratio is 1:1:9:1. Following the design,we adjust the number of blocks in each stage from (3,4,6,3) in ResNet-50 to (3,3,9,3), which also aligns the FLOPs with Swin-T. This improves the model accuracy from $78 . 8 \\%$ to $7 9 . 4 \\%$ .Notably, researchers have thoroughly investigated the distribution of computation [53,54],and a more optimal design is likely to exist. ",
        "bbox": [
            503,
            619,
            892,
            829
        ],
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "From now on, we willuse this stage compute ratio. ",
        "bbox": [
            522,
            832,
            854,
            845
        ],
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "Changing stem to “Patchify\". Typically, the stem cell design is concerned with how the input images will be processed at the network's beginning. Due to the redundancy inherent in natural images, a common stem cell will aggressively downsample the input images to an appropriate feature map size in both standard ConvNets and vision Transformers. The stem cell in standard ResNet contains a $7 \\times 7$ convolution layer with stride 2,followed by a max pool,which results in a $4 \\times$ downsampling of the input images. In vision Transformers,a more aggressive“patchify”strategy is used as the stem cell, which corresponds to a large kernel size (e.g. kernel size $= 1 4$ or 16)and non-overlapping convolution. Swin Transformer uses a similar“patchify\" layer, but with a smaller patch size of 4 to accommodate the architecture's multi-stage design.We replace the ResNet-style stem cell with a patchify layer implemented using a $4 \\times 4$ ,stride 4 convolutional layer. The accuracy has changed from $7 9 . 4 \\%$ to $7 9 . 5 \\%$ . This suggests that the stem cell in a ResNet may be substituted with a simpler“patchify” layer a la ViT which will result in similar performance. ",
        "bbox": [
            501,
            856,
            892,
            900
        ],
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "",
        "bbox": [
            80,
            90,
            468,
            347
        ],
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "We will use the“patchify stem”( $4 { \\times } 4$ non-overlapping convolution) in the network. ",
        "bbox": [
            78,
            349,
            467,
            377
        ],
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "2.3. ResNeXt-ify ",
        "text_level": 1,
        "bbox": [
            80,
            390,
            205,
            406
        ],
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "In this part, we attempt to adopt the idea of ResNeXt [87], which has a better FLOPs/accuracy trade-off than a vanilla ResNet. The core component is grouped convolution, where the convolutional filters are separated into different groups. At a high level, ResNeXt's guiding principle is to “use more groups, expand width\". More precisely, ResNeXt employs grouped convolution for the $3 \\times 3$ conv layer in a bottleneck block.As this significantly reduces the FLOPs,the network width is expanded to compensate for the capacity loss. ",
        "bbox": [
            80,
            412,
            468,
            547
        ],
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "In our case we use depthwise convolution,a special case of grouped convolution where the number of groups equals the number of channels.Depthwise conv has been popularized by MobileNet [34] and Xception [11]. We note that depthwise convolution is similar to the weighted sum operation in self-attention,which operates on a per-channel basis,i.e., only mixing information in the spatial dimension. The combination of depthwise conv and $1 \\times 1$ convs leads to a separation of spatial and channel mixing,a property shared by vision Transformers,where each operation either mixes information across spatial or channel dimension, but not both.The use of depthwise convolution effectively reduces the network FLOPs and, as expected, the accuracy. Following the strategy proposed in ResNeXt, we increase the network width to the same number of channels as Swin-T's (from 64 to 96). This brings the network performance to $8 0 . 5 \\%$ with increased FLOPs (5.3G). ",
        "bbox": [
            80,
            550,
            468,
            804
        ],
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "We will now employ the ResNeXt design. ",
        "bbox": [
            101,
            806,
            364,
            821
        ],
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "2.4.Inverted Bottleneck ",
        "text_level": 1,
        "bbox": [
            80,
            833,
            263,
            848
        ],
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "One important design in every Transformer block is that it creates an inverted bottleneck, i.e., the hidden dimension of the MLP block is four times wider than the input dimension (see Figure 4). Interestingly, this Transformer design is connected to the inverted bottleneck design with an expansion ratio of 4 used in ConvNets. The idea was popularized by MobileNetV2 [61], and has subsequently gained traction in several advanced ConvNet architectures [70,71]. ",
        "bbox": [
            80,
            856,
            468,
            900
        ],
        "page_idx": 3
    },
    {
        "type": "image",
        "img_path": "images/1ec0f4816e3bdbe2b67dcd2c96ae7468a5d2e4599419bea4e866daeac37b5aa8.jpg",
        "image_caption": [
            "Figure 3.Block modifications and resulted specifications. (a) is a ResNeXt block; in (b) we create an inverted botleneck block and in (c) the position of the spatial depthwise conv layer is moved up. "
        ],
        "image_footnote": [],
        "bbox": [
            504,
            92,
            888,
            190
        ],
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "",
        "bbox": [
            503,
            255,
            890,
            329
        ],
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "Here we explore the inverted bottleneck design. Figure 3 (a) to (b) illustrate the configurations.Despite the increased FLOPs for the depthwise convolution layer, this change reduces the whole network FLOPs to 4.6G, due to the significant FLOPs reduction in the downsampling residual blocks' shortcut $1 \\times 1$ conv layer. Interestingly,this results in slightly improved performance ( $8 0 . 5 \\%$ to $8 0 . 6 \\%$ ). In theResNet-200 / Swin-B regime, this step brings even more gain $8 1 . 9 \\%$ to $8 2 . 6 \\%$ also with reduced FLOPs. ",
        "bbox": [
            503,
            330,
            892,
            464
        ],
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "We will now use inverted bottlenecks. ",
        "bbox": [
            522,
            467,
            764,
            479
        ],
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "2.5. Large Kernel Sizes ",
        "text_level": 1,
        "bbox": [
            503,
            489,
            679,
            506
        ],
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "In this part of the exploration,we focus on the behavior of large convolutional kernels. One of the most distinguishing aspects of vision Transformers is their non-local self-attention,which enables each layer to have a global receptive field. While large kernel sizes have been used in the past with ConvNets [4O,68], the gold standard (popularized by VGGNet [65]) is to stack small kernel-sized $( 3 \\times 3 )$ conv layers,which have efficient hardware implementations on modern GPUs [41]. Although Swin Transformers reintroduced the local window to the self-attention block, the window size is at least $7 \\times 7$ ， significantly larger than the ResNe(X)t kernel size of $3 \\times 3$ . Here we revisit the use of large kernel-sized convolutions for ConvNets. ",
        "bbox": [
            503,
            511,
            892,
            705
        ],
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "Moving up depthwise conv layer. To explore large kernels, one prerequisite is to move up the position of the depthwise conv layer (Figure 3 (b) to (c)). That is a design decision also evident in Transformers: the MSA block is placed prior to the MLP layers.As we have an inverted bottleneck block, this is a natural design choice — the complex/inefficient modules (MSA,large-kernel conv) will have fewer channels, while the efficient, dense $1 \\times 1$ layers will do the heavy lifting. This intermediate step reduces the FLOPs to 4.1G, resulting in a temporary performance degradation to $7 9 . 9 \\%$ ",
        "bbox": [
            503,
            713,
            892,
            863
        ],
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "Increasing the kernel size. With all of these preparations, the benefit of adopting larger kernel-sized convolutions is significant. We experimented with several kernel sizes,including 3,5,7,9,and 11. The network's performance increases from $7 9 . 9 \\%$ $( 3 \\times 3 )$ to $8 0 . 6 \\%$ $( 7 \\times 7 )$ ，while the network's FLOPs stay roughly the same.Additionally, we observe that the benefit of larger kernel sizes reaches a saturation point at $7 \\times 7$ .We verified this behavior in the large capacity model too: a ResNet-2OO regime model does not exhibit further gain when we increase the kernel size beyond $7 \\times 7$ ",
        "bbox": [
            501,
            871,
            892,
            900
        ],
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "",
        "bbox": [
            80,
            90,
            468,
            210
        ],
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "We will use $7 \\times 7$ depthwise conv in each block ",
        "bbox": [
            102,
            212,
            405,
            227
        ],
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "At this point, we have concluded our examination of network architectures on a macro scale. Intriguingly, a significant portion of the design choices taken in a vision Transformer may be mapped to ConvNet instantiations. ",
        "bbox": [
            80,
            228,
            470,
            287
        ],
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "2.6. Micro Design ",
        "text_level": 1,
        "bbox": [
            80,
            297,
            215,
            313
        ],
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "In this section,we investigate several other architectural differences at a micro scale — most of the explorations here are done at the layer level, focusing on specific choices of activation functions and normalization layers. ",
        "bbox": [
            78,
            320,
            468,
            381
        ],
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "Replacing ReLU with GELU One discrepancy between NLP and vision architectures is the specifics of which activation functions to use.Numerous activation functions have been developed over time,but the Rectified Linear Unit (ReLU) [49] is still extensively used in ConvNets due to its simplicity and efficiency.ReLU is also used as an activation function in the original Transformer paper [77]. The Gaussian Error Linear Unit,or GELU[32],which can be thought of as a smoother variant ofReLU,is utilized in the most advanced Transformers,including Google's BERT[18] and OpenAI's GPT-2 [52],and,most recently,ViTs.We find that ReLU can be substituted with GELU in our ConvNet too,although the accuracy stays unchanged $( 8 0 . 6 \\% )$ ",
        "bbox": [
            80,
            387,
            468,
            583
        ],
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "Fewer activation functions. One minor distinction between a Transformer and a ResNet block is that Transformers have fewer activation functions. Consider a Transformer block with key/query/value linear embedding layers, the projection layer,and two linear layers inan MLP block.There is only one activation function present in the MLP block. In comparison,it is common practice to append an activation function to each convolutional layer, including the $1 \\times 1$ convs.Here we examine how performance changes when we stick to the same strategy. As depicted in Figure 4, we eliminate all GELU layers from the residual block except for one between two $1 \\times 1$ layers, replicating the style of a Transformer block. This process improves the result by $0 . 7 \\%$ to $8 1 . 3 \\%$ ,practically matching the performance of Swin-T. ",
        "bbox": [
            80,
            592,
            468,
            801
        ],
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "We will now use a single GELU activation in each block ",
        "bbox": [
            99,
            804,
            465,
            818
        ],
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "Fewer normalization layers. Transformer blocks usually have fewer normalization layers as well. Here we remove two BatchNorm (BN) layers, leaving only one BN layer before the conv $1 \\times 1$ layers.This further boosts the performance to $8 1 . 4 \\%$ ,already surpassing Swin-T's result. Note ",
        "bbox": [
            80,
            825,
            467,
            900
        ],
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "Swin Transformer Block ",
        "text_level": 1,
        "bbox": [
            506,
            93,
            681,
            106
        ],
        "page_idx": 4
    },
    {
        "type": "image",
        "img_path": "images/e8afc5a9a76d18c8639ea0b7d4d491f26f0ce441cb5363c6685ae440db57e5bb.jpg",
        "image_caption": [
            "Figure 4.Block designs for a ResNet,a Swin Transformer,and a ConvNeXt. Swin Transformer's block is more sophisticated due to the presence of multiple specialized modules and two residual connections.For simplicity,we note the linear layers in Transformer MLP blocks also as $^ { 6 6 } 1 \\times 1$ convs” since they are equivalent. "
        ],
        "image_footnote": [],
        "bbox": [
            509,
            109,
            893,
            414
        ],
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "that we have even fewer normalization layers per block than Transformers,as empirically we find that adding one additional BN layer at the beginning of the block does not improve the performance. ",
        "bbox": [
            501,
            503,
            892,
            563
        ],
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "Substituting BN with LN. BatchNorm [38] is an essential component in ConvNets as it improves the convergence and reduces overfittng. However, BN also has many intricacies that can have a detrimental effect on the model's performance [84]. There have been numerous attempts at developing alternative normalization [60,75,83] techniques, but BN has remained the preferred option in most vision tasks. On the other hand,the simpler Layer Normalization [5] (LN) has been used in Transformers,resulting in good performance across different application scenarios. ",
        "bbox": [
            503,
            573,
            892,
            723
        ],
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "Directly substituting LN for BN in the original ResNet will result in suboptimal performance [83]. With all the modifications in network architecture and training techniques, here we revisit the impact of using LN in place of BN.We observe that our ConvNet model does not have any difficulties training with LN; in fact, the performance is slightly better, obtaining an accuracy of $8 1 . 5 \\%$ ",
        "bbox": [
            503,
            724,
            892,
            829
        ],
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "From now on,we will use one LayerNorm as our choice ofnormalization ineachresidual block. ",
        "bbox": [
            501,
            830,
            890,
            859
        ],
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "Separate downsampling layers.In ResNet, the spatial downsampling is achieved by the residual block at the start of each stage, using $3 \\times 3$ conv with stride 2 (and $1 \\times 1$ conv with stride 2 at the shortcut connection). In Swin Transformers,a separate downsampling layer is added between stages.We explore a similar strategy in which we use $2 \\times 2$ conv layers with stride 2 for spatial downsampling. This modification surprisingly leads to diverged training.Further investigation shows that,adding normalization layers wherever spatial resolution is changed can help stablize training.These include several LN layers also used in Swin Transformers: one before each downsampling layer, one after the stem, and one after the final global average pooling. We can improve the accuracy to $8 2 . 0 \\%$ , significantly exceeding Swin-T's $8 1 . 3 \\%$ ",
        "bbox": [
            501,
            871,
            890,
            900
        ],
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "",
        "bbox": [
            80,
            92,
            468,
            271
        ],
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "We will use separate downsampling layers. This brings us to our final model, which we have dubbed ConvNeXt. ",
        "bbox": [
            80,
            273,
            468,
            303
        ],
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "A comparison of ResNet, Swin,and ConvNeXt block structures can be found in Figure 4.A comparison of ResNet-50, Swin-T and ConvNeXt-T's detailed architecture specificationscanbe foundin Table9. ",
        "bbox": [
            80,
            304,
            470,
            363
        ],
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "Closing remarks.We have finished our first “playthrough\" and discovered ConvNeXt, a pure ConvNet, that can outperform the Swin Transformer for ImageNet-1K classification in this compute regime. It is worth noting that all design choices discussed so far are adapted from vision Transformers.In addition, these designs are not novel even in the ConvNet literature - they have all been researched separately, but not collectively, over the last decade. Our ConvNeXt model has approximately the same FLOPs, #params., throughput,and memory use as the Swin Transformer, but does not require specialized modules such as shifted window attention or relative position biases. ",
        "bbox": [
            80,
            375,
            470,
            554
        ],
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "These findings are encouraging but not yet completely convincing — our exploration thus far has been limited to a small scale, but vision Transformers’ scaling behavior is what truly distinguishes them. Additionally, the question of whether a ConvNet can compete with Swin Transformers on downstream tasks such as object detection and semantic segmentation is a central concern for computer vision practitioners.In the next section,we will scale up our ConvNeXt models both in terms of data and model size,and evaluate them on a diverse set of visual recognition tasks. ",
        "bbox": [
            80,
            558,
            468,
            707
        ],
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "3. Empirical Evaluations on ImageNet ",
        "text_level": 1,
        "bbox": [
            78,
            723,
            400,
            739
        ],
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "We construct different ConvNeXt variants, ConvNeXtT/S/B/L, to be of similar complexities to Swin-T/S/B/L [45]. ConvNeXt-T/B is the end product of the “modernizing” procedure on ResNet-50/20O regime, respectively. In addition, we build a larger ConvNeXt-XL to further test the scalability of ConvNeXt. The variants only differ in the number of channels $C$ ,and the number of blocks $B$ in each stage. Following both ResNets and Swin Transformers,the number of channels doubles at each new stage. We summarize the configurations below: ",
        "bbox": [
            80,
            750,
            470,
            900
        ],
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "● ConvNeXt-T: $C = ( 9 6 , 1 9 2 , 3 8 4 , 7 6 8 )$ ， $B = ( 3 , 3 , 9 , 3 )$ ·ConvNeXt-S: $C = ( 9 6 , 1 9 2 , 3 8 4 , 7 6 8 )$ ， $B = ( 3 , 3 , 2 7 , 3 )$ ConvNeXt-B: $C = ( 1 2 8 , 2 5 6 , 5 1 2 , 1 0 2 4 )$ ， $B = ( 3 , 3 , 2 7 , 3 )$ ·ConvNeXt-L: $C = ( 1 9 2 , 3 8 4 , 7 6 8 , 1 5 3 6 )$ ， $B = ( 3 , 3 , 2 7 , 3 )$ ·ConvNeXt-XL: $C = ( 2 5 6 , 5 1 2 , 1 0 2 4 , 2 0 4 8 )$ ， $B = ( 3 , 3 , 2 7 , 3 )$ ",
        "bbox": [
            501,
            92,
            885,
            170
        ],
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "3.1. Settings ",
        "text_level": 1,
        "bbox": [
            503,
            179,
            596,
            194
        ],
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "The ImageNet-1K dataset consists of 1000 object classes with 1.2M training images. We report ImageNet-1K top-1 accuracy on the validation set. We also conduct pre-training on ImageNet-22K,a larger dataset of 21841 classes (a superset of the 1000 ImageNet-1K classes) with ${ \\sim } 1 4 \\mathbf { M }$ images for pre-training,and then fine-tune the pre-trained model on ImageNet-1K for evaluation. We summarize our training setups below. More details can be found in Appendix A. ",
        "bbox": [
            503,
            202,
            890,
            321
        ],
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "Training on ImageNet-1K. We train ConvNeXts for 300 epochs using AdamW [46] with a learning rate of 4e-3. There is a 2O-epoch linear warmup and a cosine decaying schedule afterward. We use a batch size of 4096 and a weight decay of O.O5. For data augmentations,we adopt common schemes including Mixup [9O], Cutmix [89], RandAugment [14],and Random Erasing [91]. We regularize the networks with Stochastic Depth [37] and Label Smoothing [69]. Layer Scale [74] of initial value le-6 is applied. We use Exponential Moving Average (EMA) [51] as we find it alleviates larger models’overfitting. ",
        "bbox": [
            503,
            329,
            892,
            493
        ],
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "Pre-training on ImageNet-22K. We pre-train ConvNeXts on ImageNet-22K for 90 epochs with a warmup of 5 epochs. We do not use EMA. Other settings follow ImageNet-1K. ",
        "bbox": [
            501,
            501,
            892,
            545
        ],
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "Fine-tuning on ImageNet-1K. We fine-tune ImageNet22K pre-trained models on ImageNet-1K for 30 epochs.We use AdamW,a learning rate of 5e-5,cosine learning rate schedule,layer-wise learning rate decay [6,12], no warmup, a batch size of 512,and weight decay of 1e-8. The default pre-training, fine-tuning,and testing resolution is $2 2 4 ^ { 2 }$ . Additionally, we fine-tune at a larger resolution of $3 8 4 ^ { 2 }$ ,for both ImageNet-22K and ImageNet-1K pre-trained models. ",
        "bbox": [
            503,
            551,
            892,
            671
        ],
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "Compared with ViTs/Swin Transformers, ConvNeXts are simpler to fine-tune at different resolutions,as the network is fully-convolutional and there is no need to adjust the input patch size or interpolate absolute/relative position biases. ",
        "bbox": [
            503,
            672,
            892,
            732
        ],
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "3.2. Results ",
        "text_level": 1,
        "bbox": [
            503,
            741,
            591,
            757
        ],
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "ImageNet-1K. Table 1 (upper) shows the result comparison with two recent Transformer variants,DeiT[73] and Swin Transformers [45],as well as two ConvNets from architecture search - RegNets [54], EfficientNets [71] and EfficientNetsV2[72]. ConvNeXt competes favorably with two strong ConvNet baselines (RegNet [54] and EfficientNet [71]) in terms of the accuracy-computation trade-off, as well as the inference throughputs. ConvNeXt also outperforms Swin Transformer of similar complexities across the board, sometimes with a substantial margin (e.g. $0 . 8 \\%$ for ConvNeXt-T).Without specialized modules such as shifted windows or relative position bias, ConvNeXts also enjoy improved throughput compared to Swin Transformers. ",
        "bbox": [
            503,
            765,
            892,
            900
        ],
        "page_idx": 5
    },
    {
        "type": "table",
        "img_path": "images/ba622b9864105d0a0193afdfbdd8977cb514a5d5177e17bb31b1f2fd5ab74518.jpg",
        "table_caption": [
            "model ",
            "image #param. FLOPs throughputIN-1K ",
            "Table 1. Classification accuracy on ImageNet-1K. Similar to Transformers,ConvNeXt also shows promising scaling behavior with higher-capacity models and a larger (pre-training) dataset. Inference throughput is measured on a $\\mathrm { V 1 0 0 G P U }$ ,following [45]. On an A10o GPU, ConvNeXt can have a much higher throughput than Swin Transformer. See Appendix E. $( \\pmb { \\pi } ) \\mathrm { V i T }$ results with 90-epoch AugReg [67] training,provided through personal communication with the authors. "
        ],
        "table_footnote": [],
        "table_body": "<table><tr><td></td><td>size P</td><td></td><td></td><td>(image/s) top-1 acc.</td><td></td></tr><tr><td colspan=\"6\">ImageNet-1K trained models</td></tr><tr><td>·RegNetY-16G [54]</td><td>2242</td><td>84M</td><td>16.0G</td><td>334.7</td><td>82.9</td></tr><tr><td>·EffNet-B7 [71]</td><td>600²</td><td>66M</td><td>37.0G</td><td>55.1</td><td>84.3</td></tr><tr><td>·EffNetV2-L [72]</td><td>480²</td><td>120M</td><td>53.0G</td><td>83.7</td><td>85.7</td></tr><tr><td>DeiT-S [73]</td><td>2242</td><td>22M</td><td>4.6G</td><td>978.5</td><td>79.8</td></tr><tr><td>DeiT-B [73]</td><td>2242</td><td>87M</td><td>17.6G</td><td>302.1</td><td>81.8</td></tr><tr><td>Swin-T</td><td>2242</td><td>28M</td><td>4.5G</td><td>757.9</td><td>81.3</td></tr><tr><td>· ConvNeXt-T</td><td>2242</td><td>29M</td><td>4.5G</td><td>774.7</td><td>82.1</td></tr><tr><td>○ Swin-S</td><td>224²</td><td>50M</td><td>8.7G</td><td>436.7</td><td>83.0</td></tr><tr><td>· ConvNeXt-S</td><td>224²</td><td>50M</td><td>8.7G</td><td>447.1</td><td>83.1</td></tr><tr><td> Swin-B</td><td>224²</td><td>88M</td><td>15.4G</td><td>286.6</td><td>83.5</td></tr><tr><td>· ConvNeXt-B</td><td>224²</td><td>89M</td><td>15.4G</td><td>292.1</td><td>83.8</td></tr><tr><td>0 Swin-B</td><td>3842</td><td>88M</td><td>47.1G</td><td>85.1</td><td>84.5</td></tr><tr><td>· ConvNeXt-B</td><td>384²</td><td>89M</td><td>45.0G</td><td>95.7</td><td>85.1</td></tr><tr><td>· ConvNeXt-L</td><td>224²</td><td>198M</td><td>34.4G</td><td>146.8</td><td>84.3</td></tr><tr><td>· ConvNeXt-L</td><td>384²</td><td>198M</td><td>101.0G</td><td>50.4</td><td>85.5</td></tr><tr><td colspan=\"6\">ImageNet-22K pre-trained models</td></tr><tr><td>·R-101x3 [39]</td><td>3842</td><td>388M</td><td>204.6G</td><td>1</td><td>84.4</td></tr><tr><td>·R-152x4 [39]</td><td>480²</td><td>937M</td><td>840.5G</td><td>-</td><td>85.4</td></tr><tr><td>·EffNetV2-L [72]</td><td>480²</td><td>120M</td><td>53.0G</td><td>83.7</td><td>86.8</td></tr><tr><td>·EffNetV2-XL [72]</td><td>4802</td><td>208M</td><td>94.0G</td><td>56.5</td><td>87.3</td></tr><tr><td>ViT-B/16()[67]</td><td>3842</td><td>87M</td><td>55.5G</td><td>93.1</td><td>85.4</td></tr><tr><td>o ViT-L/16 (a) [67]</td><td>3842</td><td>305M</td><td>191.1G</td><td>28.5</td><td>86.8</td></tr><tr><td>·ConvNeXt-T</td><td>2242</td><td>29M</td><td>4.5G</td><td>774.7</td><td>82.9</td></tr><tr><td>· ConvNeXt-T</td><td>3842</td><td>29M</td><td>13.1G</td><td>282.8</td><td>84.1</td></tr><tr><td>· ConvNeXt-S</td><td>224²</td><td> 50M</td><td>8.7G</td><td>447.1</td><td>84.6</td></tr><tr><td>· ConvNeXt-S</td><td>384²</td><td>50M</td><td>25.5G</td><td>163.5</td><td>85.8</td></tr><tr><td>0 Swin-B</td><td>2242</td><td>88M</td><td>15.4G</td><td>286.6</td><td>85.2</td></tr><tr><td>· ConvNeXt-B</td><td>224²</td><td>89M</td><td>15.4G</td><td>292.1</td><td>85.8</td></tr><tr><td>0 Swin-B</td><td>384²</td><td>88M</td><td>47.0G</td><td>85.1</td><td>86.4</td></tr><tr><td>· ConvNeXt-B</td><td>3842</td><td>89M</td><td>45.1G</td><td>95.7</td><td>86.8</td></tr><tr><td>0 Swin-L</td><td>2242</td><td>197M</td><td>34.5G</td><td>145.0</td><td>86.3</td></tr><tr><td>· ConvNeXt-L</td><td>224²</td><td>198M</td><td>34.4G</td><td>146.8</td><td>86.6</td></tr><tr><td>0 Swin-L</td><td>384²</td><td>197M</td><td>103.9G</td><td>46.0</td><td>87.3</td></tr><tr><td>· ConvNeXt-L</td><td>384²</td><td>198M</td><td>101.0G</td><td>50.4</td><td>87.5</td></tr><tr><td>· ConvNeXt-XL</td><td>224²</td><td>350M</td><td>60.9G</td><td>89.3</td><td>87.0</td></tr><tr><td>· ConvNeXt-XL</td><td>384²</td><td>350M</td><td>179.0G</td><td>30.2</td><td>87.8</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></table>",
        "bbox": [
            80,
            106,
            472,
            637
        ],
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "",
        "bbox": [
            78,
            775,
            467,
            834
        ],
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "A highlight from the results is ConvNeXt-B at $3 8 4 ^ { 2 }$ ：it outperforms Swin-B by $0 . 6 \\%$ $8 5 . 1 \\%$ vs. $8 4 . 5 \\%$ ), but with $12 . 5 \\%$ higher inference throughput (95.7 vs. 85.1 image/s). We note that the FLOPs/throughput advantage of ConvNeXt",
        "bbox": [
            80,
            840,
            468,
            900
        ],
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "B over Swin-B becomes larger when the resolution increases from $2 2 4 ^ { 2 }$ to $3 8 4 ^ { 2 }$ . Additionally, we observe an improved result of $8 5 . 5 \\%$ when further scaling to ConvNeXt-L. ",
        "bbox": [
            501,
            92,
            890,
            136
        ],
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "ImageNet-22K. We present results with models fine-tuned from ImageNet-22K pre-training at Table 1 (lower). These experiments are important since a widely held view is that vision Transformers have fewer inductive biases thus can perform better than ConvNets when pre-trained on a larger scale. Our results demonstrate that properly designed ConvNets are not inferior to vision Transformers when pre-trained with large dataset — ConvNeXts still perform on par or better than similarly-sized Swin Transformers,with slightly higher throughput. Additionally,our ConvNeXt-XL model achieves an accuracy of $8 7 . 8 \\%$ —a decent improvement over ConvNeXt-L at $3 8 4 ^ { 2 }$ , demonstrating that ConvNeXts are scalable architectures. ",
        "bbox": [
            503,
            143,
            892,
            338
        ],
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "On ImageNet-1K, EficientNetV2-L,a searched architecture equipped with advanced modules (such as Squeeze-andExcitation [35]) and progressive training procedure achieves top performance. However, with ImageNet-22K pre-training, ConvNeXt is able to outperform EfficientNetV2, further demonstrating the importance of large-scale training. ",
        "bbox": [
            503,
            339,
            892,
            430
        ],
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "In Appendix B,we discuss robustness and out-of-domain generalization results for ConvNeXt. ",
        "bbox": [
            501,
            431,
            890,
            459
        ],
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "3.3.Isotropic ConvNeXt vs. ViT ",
        "text_level": 1,
        "bbox": [
            503,
            469,
            743,
            486
        ],
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "In this ablation, we examine if our ConvNeXt block design is generalizable to ViT-style [2O] isotropic architectures which have no downsampling layers and keep the same feature resolutions (e.g. $1 4 \\times 1 4$ ）at all depths.We construct isotropic ConvNeXt-S/B/L using the same feature dimensions as ViT-S/B/L (384/768/1024). Depths are set at 18/18/36 to match the number of parameters and FLOPs. The block structure remains the same (Fig. 4). We use the supervised training results from DeiT[73] for ViT-S/B and MAE[26] for ViT-L,as they employ improved training procedures over the original ViTs [2O]. ConvNeXt models are trained with the same settings as before,but with longer warmup epochs.Results for ImageNet-1K at $2 2 4 ^ { 2 }$ resolution are in Table 2. We observe ConvNeXt can perform generally on par with ViT, showing that our ConvNeXt block design is competitive when used in non-hierarchical models. ",
        "bbox": [
            503,
            493,
            892,
            734
        ],
        "page_idx": 6
    },
    {
        "type": "table",
        "img_path": "images/f5e91ec6106b194868b43d20d248bd61483be4f7bed55d832117c6462a95c39d.jpg",
        "table_caption": [
            "Table 2. Comparing isotropic ConvNeXt and ViT. Training memory is measured on V100 GPUs with 32 per-GPU batch size. "
        ],
        "table_footnote": [],
        "table_body": "<table><tr><td>model</td><td>#param.FLOPs</td><td></td><td>throughput (image/s)</td><td>training mem. (GB)</td><td>IN-1K acc.</td></tr><tr><td>ViT-S</td><td>22M</td><td>4.6G</td><td>978.5</td><td>4.9</td><td>79.8</td></tr><tr><td>· ConvNeXt-S (iso.)</td><td>22M</td><td>4.3G</td><td>1038.7</td><td>4.2</td><td>79.7</td></tr><tr><td> ViT-B</td><td>87M</td><td>17.6G</td><td>302.1</td><td>9.1</td><td>81.8</td></tr><tr><td>·ConvNeXt-B (iso.)</td><td>87M</td><td>16.9G</td><td>320.1</td><td>7.7</td><td>82.0</td></tr><tr><td>o ViT-L</td><td>304M</td><td>61.6G</td><td>93.1</td><td>22.5</td><td>82.6</td></tr><tr><td>·ConvNeXt-L (iso.)</td><td>306M</td><td>59.7G</td><td>94.4</td><td>20.4</td><td>82.6</td></tr></table>",
        "bbox": [
            503,
            758,
            887,
            858
        ],
        "page_idx": 6
    },
    {
        "type": "table",
        "img_path": "images/064127150c4c324746faacf4290236ab6b9e97b5819eb07a1ec74820bfad6ca1.jpg",
        "table_caption": [
            "Table 3. COCO object detection and segmentation results using Mask-RCNN and Cascade Mask-RCNN.\\* indicates that the model is pre-trained on ImageNet-22K.ImageNet-1K pre-trained Swin results are from their Github repository [3].AP numbers of the ResNet-50 and X101 models are from [45].We measure FPS on an A100 GPU.FLOPs are calculated with image size (1280, 800). "
        ],
        "table_footnote": [],
        "table_body": "<table><tr><td colspan=\"8\">Mask-RCNN 3× schedule</td></tr><tr><td>oSwin-T</td><td colspan=\"6\">267G 23.1 46.0 68.1 50.3</td><td>65.1 44.9</td></tr><tr><td>·ConvNeXt-T</td><td></td><td>262G 25.6 46.2</td><td>67.9</td><td>50.8</td><td>41.6 41.7</td><td>65.0</td><td>44.9</td></tr><tr><td colspan=\"8\">Cascade Mask-RCNN3× schedule</td></tr><tr><td>·ResNet-50</td><td>739G 16.2 46.3</td><td></td><td>64.3</td><td>50.5</td><td>40.1</td><td>61.7</td><td>43.4</td></tr><tr><td>·X101-32</td><td>819G</td><td>13.8 48.1</td><td>66.5</td><td>52.4</td><td>41.6</td><td>63.9</td><td>45.2</td></tr><tr><td>·X101-64</td><td>972G 12.6</td><td>48.3</td><td>66.4</td><td>52.3</td><td>41.7</td><td>64.0</td><td>45.1</td></tr><tr><td>Swin-T</td><td>745G 12.2</td><td>50.4</td><td>69.2</td><td>54.7</td><td>43.7</td><td>66.6</td><td>47.3</td></tr><tr><td>·ConvNeXt-T</td><td>741G 13.5</td><td> 50.4</td><td>69.1</td><td>54.8</td><td>43.7</td><td>66.5</td><td>47.3</td></tr><tr><td>o Swin-S</td><td>838G 11.4</td><td>51.9</td><td>70.7</td><td>56.3</td><td>45.0</td><td>68.2</td><td>48.8</td></tr><tr><td>·ConvNeXt-S</td><td>827G 12.0</td><td>51.9</td><td>70.8</td><td>56.5</td><td>45.0</td><td>68.4</td><td>49.1</td></tr><tr><td>Swin-B</td><td>982G 10.7</td><td>51.9</td><td>70.5</td><td>56.4</td><td>45.0</td><td>68.1</td><td>48.9</td></tr><tr><td>·ConvNeXt-B</td><td>964G 11.4</td><td> 52.7</td><td>71.3</td><td>57.2</td><td>45.6</td><td>68.9</td><td>49.5</td></tr><tr><td>Swin-Bt</td><td>982G 10.7</td><td>53.0</td><td>71.8</td><td>57.5</td><td>45.8</td><td>69.4</td><td>49.7</td></tr><tr><td>·ConvNeXt-B†</td><td>964G 11.5</td><td> 54.0</td><td>73.1</td><td>58.8</td><td>46.9</td><td>70.6</td><td>51.3</td></tr><tr><td>Swin-Lt</td><td>1382G 9.2</td><td>53.9</td><td>72.4</td><td>58.8</td><td>46.7</td><td>70.1</td><td>50.8</td></tr><tr><td>•ConvNeXt-L‡</td><td>1354G 10.0</td><td> 54.8</td><td>73.8</td><td>59.8</td><td>47.6</td><td>71.3</td><td>51.7</td></tr><tr><td>·ConvNeXt-XL‡ 1898G 8.6</td><td></td><td>55.2</td><td>74.2</td><td>59.9</td><td>47.7</td><td>71.6</td><td>52.2</td></tr></table>",
        "bbox": [
            81,
            111,
            470,
            338
        ],
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "4. Empirical Evaluation on Downstream Tasks ",
        "text_level": 1,
        "bbox": [
            80,
            459,
            467,
            477
        ],
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "Object detection and segmentation on COCO. We finetune Mask R-CNN [27] and Cascade Mask R-CNN [9] on the COCO dataset with ConvNeXt backbones.Following Swin Transformer [45], we use multi-scale training,AdamW optimizer, and a $3 \\times$ schedule.Further details and hyperparameter settings can be found in Appendix A.3. ",
        "bbox": [
            80,
            486,
            468,
            577
        ],
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "Table 3 shows object detection and instance segmentation results comparing Swin Transformer, ConvNeXt, and traditional ConvNet such as ResNeXt.Across different model complexities,ConvNeXt achieves on-par or better performance than Swin Transformer. When scaled up to bigger models (ConvNeXt-B/L/XL) pre-trained on ImageNet-22K, in many cases ConvNeXt is significantly better (e.g. $+ 1 . 0$ AP) than Swin Transformers in terms of box and mask AP. ",
        "bbox": [
            80,
            578,
            470,
            698
        ],
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "Semantic segmentation on ADE2oK. We also evaluate ConvNeXt backbones on the ADE20K semantic segmentation task with UperNet [85].All model variants are trained for 160K iterations with a batch size of 16. Other experimental settings follow [6] (see Appendix A.3 for more details). In Table 4, we report validation mIoU with multi-scale testing. ConvNeXt models can achieve competitive performance across different model capacities, further validating the effectiveness of our architecture design. ",
        "bbox": [
            80,
            709,
            468,
            843
        ],
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "Remarks on model efficiency. Under similar FLOPs,models with depthwise convolutions are known to be slower and consume more memory than ConvNets with only dense convolutions. It is natural to ask whether the design of ConvNeXt will render it practically ineffcient. As demonstrated throughout the paper, the inference throughputs of ConvNeXts are comparable to or exceed that of Swin Transformers.This is true for both classification and other tasks requiring higher-resolution inputs (see Table 1,3 for comparisons of throughput/FPS).Furthermore,we notice that training ConvNeXts requires less memory than training Swin Transformers. For example, training Cascade Mask-RCNN using ConvNeXt-B backbone consumes 17.4GB of peak memory with a per-GPU batch size of 2,while the reference number for Swin-B is 18.5GB.In comparison to vanilla ViT, both ConvNeXt and Swin Transformer exhibit a more favorable accuracy-FLOPs trade-off due to the local computations. It is worth noting that this improved efficiency is a result of the ConvNet inductivebias,and is not directlyrelated to the self-attention mechanism in vision Transformers. ",
        "bbox": [
            78,
            856,
            468,
            900
        ],
        "page_idx": 7
    },
    {
        "type": "table",
        "img_path": "images/e872c8c5042d045d15ee5c6f9518fd4abf3fcac9604dc27dccab12c41d4bc3c2.jpg",
        "table_caption": [
            "Table 4.ADE20K validation results using UperNet [85].  indicates IN-22K pre-training. Swins’results are from its GitHub repository [2]. Following Swin,we report mloU results with multiscale testing.FLOPs are based on input sizes of (2048,512) and (2560,640) for IN-1K and IN-22K pre-trained models,respectively. "
        ],
        "table_footnote": [],
        "table_body": "<table><tr><td colspan=\"5\">ImageNet-1K pre-trained</td></tr><tr><td>Swin-T 。</td><td>512</td><td>45.8</td><td>60M</td><td>945G</td></tr><tr><td>·ConvNeXt-T</td><td>512²</td><td>46.7</td><td>60M</td><td>939G</td></tr><tr><td>o Swin-S</td><td>5122</td><td>49.5</td><td>81M</td><td>1038G</td></tr><tr><td>·ConvNeXt-S</td><td> 512²</td><td>49.6</td><td>82M</td><td>1027G</td></tr><tr><td>Swin-B</td><td>512²</td><td>49.7</td><td>121M</td><td>1188G</td></tr><tr><td>·ConvNeXt-B</td><td>512²</td><td>49.9</td><td>122M</td><td>1170G</td></tr><tr><td colspan=\"5\">ImageNet-22K pre-trained</td></tr><tr><td>Swin-Bt</td><td>640²</td><td>51.7</td><td>121M</td><td>1841G</td></tr><tr><td>·ConvNeXt-Bt</td><td>640²</td><td> 53.1</td><td>122M</td><td>1828G</td></tr><tr><td>Swin-L‡</td><td>640²</td><td>53.5</td><td>234M</td><td>2468G</td></tr><tr><td>·ConvNeXt-L‡ · ConvNeXt-XL ‡</td><td>640² 640²</td><td>53.7 54.0</td><td>235M 391M</td><td>2458G 3335G</td></tr></table>",
        "bbox": [
            516,
            113,
            874,
            299
        ],
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "",
        "bbox": [
            503,
            412,
            892,
            667
        ],
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "5.Related Work ",
        "text_level": 1,
        "bbox": [
            503,
            684,
            640,
            700
        ],
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "Hybrid models.In both the pre- and post-ViT eras,the hybrid model combining convolutions and self-attentions has been actively studied. Prior to ViT, the focus was on augmenting a ConvNet with self-attention/non-local modules [8,55,66,79] to capture long-range dependencies. The original ViT [2O] first studied a hybrid configuration,and a large body of follow-up works focused on reintroducing convolutional priors to ViT, either in an explicit [15,16,21,82,86,88] or implicit [45] fashion. ",
        "bbox": [
            503,
            710,
            892,
            845
        ],
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "Recent convolution-based approaches.Han et al. [25] show that local Transformer attention is equivalent to inhomogeneous dynamic depthwise conv. The MSA block in ",
        "bbox": [
            503,
            856,
            890,
            900
        ],
        "page_idx": 7
    },
    {
        "type": "discarded",
        "text": "input crop．mIoU #param．FLOPs ",
        "bbox": [
            638,
            101,
            869,
            112
        ],
        "page_idx": 7
    },
    {
        "type": "discarded",
        "text": "FLOPs FPS APbo AAPApmask Ak k ",
        "bbox": [
            178,
            98,
            465,
            111
        ],
        "page_idx": 7
    },
    {
        "type": "discarded",
        "text": "backbone ",
        "bbox": [
            522,
            101,
            581,
            111
        ],
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "Swin is then replaced with a dynamic or regular depthwise convolution,achieving comparable performance to Swin. A concurrent work ConvMixer [4] demonstrates that,in small-scale settings,depthwise convolution can be used as a promising mixing strategy. ConvMixer uses a smaller patch size to achieve the best results,making the throughput much lower than other baselines.GFNet [56] adopts Fast Fourier Transform (FFT) for token mixing.FFT is also a form of convolution, but with a global kernel size and circular padding. Unlike many recent Transformer or ConvNet designs, one primary goal of our study is to provide an in-depth look at the process of modernizing a standard ResNet and achieving state-of-the-art performance. ",
        "bbox": [
            80,
            92,
            468,
            286
        ],
        "page_idx": 8
    },
    {
        "type": "text",
        "text": "6. Conclusions ",
        "text_level": 1,
        "bbox": [
            80,
            303,
            200,
            319
        ],
        "page_idx": 8
    },
    {
        "type": "text",
        "text": "In the 2O2Os,vision Transformers,particularly hierarchical ones such as Swin Transformers,began to overtake ConvNets as the favored choice for generic vision backbones. The widely held belief is that vision Transformers are more accurate, efficient, and scalable than ConvNets.We propose ConvNeXts,a pure ConvNet model that can compete favorably with state-of-the-art hierarchical vision Transformers across multiple computer vision benchmarks, while retaining the simplicity and efficiency of standard ConvNets.In some ways,our observations are surprising while our ConvNeXt model itself is not completely new — many design choices have all been examined separately over the last decade, but not collectively. We hope that the new results reported in this study will challenge several widely held views and prompt people to rethink the importance of convolution in computer vision. ",
        "bbox": [
            80,
            329,
            468,
            569
        ],
        "page_idx": 8
    },
    {
        "type": "text",
        "text": "Acknowledgments. We thank Kaiming He, Eric Mintun, Xingyi Zhou,Ross Girshick,and Yann LeCun for valuable discussions and feedback. ",
        "bbox": [
            80,
            579,
            468,
            623
        ],
        "page_idx": 8
    },
    {
        "type": "text",
        "text": "Appendix ",
        "text_level": 1,
        "bbox": [
            80,
            642,
            178,
            662
        ],
        "page_idx": 8
    },
    {
        "type": "text",
        "text": "In this Appendix, we provide further experimental details (§A),robustness evaluation results (§B), more modernization experiment results (§C),and a detailed network specification (§D).We further benchmark model throughput on A100 GPUs (§E).Finally, we discuss the limitations $( \\ S \\mathrm { F } )$ and societal impact (§G) of our work. ",
        "bbox": [
            80,
            670,
            467,
            761
        ],
        "page_idx": 8
    },
    {
        "type": "text",
        "text": "A. Experimental Settings ",
        "text_level": 1,
        "bbox": [
            81,
            776,
            292,
            792
        ],
        "page_idx": 8
    },
    {
        "type": "text",
        "text": "A.1. ImageNet (Pre-)training ",
        "text_level": 1,
        "bbox": [
            81,
            801,
            303,
            816
        ],
        "page_idx": 8
    },
    {
        "type": "text",
        "text": "We provide ConvNeXts’ ImageNet-1K training and ImageNet-22K pre-training settings in Table 5. The settings are used for our main results in Table 1 (Section 3.2). All ConvNeXt variants use the same setting, except the stochastic depth rate is customized for model variants. ",
        "bbox": [
            80,
            825,
            467,
            900
        ],
        "page_idx": 8
    },
    {
        "type": "text",
        "text": "For experiments in “modernizing a ConvNet\"(Section 2), we also use Table 5's setting for ImageNet-1K, except EMA is disabled,as we find using EMA severely hurts models with BatchNorm layers. ",
        "bbox": [
            501,
            92,
            892,
            151
        ],
        "page_idx": 8
    },
    {
        "type": "text",
        "text": "For isotropic ConvNeXts (Section 3.3), the setting for ImageNet-1K in Table A is also adopted, but warmup is extended to 5O epochs,and layer scale is disabled for isotropic ConvNeXt-S/B.The stochastic depth rates are O.1/0.2/0.5 for isotropic ConvNeXt-S/B/L. ",
        "bbox": [
            503,
            154,
            892,
            229
        ],
        "page_idx": 8
    },
    {
        "type": "table",
        "img_path": "images/756541429fb612fc7b3003577c996fa91643110f8ae0631e69c0f0b6f6272f82.jpg",
        "table_caption": [],
        "table_footnote": [],
        "table_body": "<table><tr><td>(pre-)training config</td><td colspan=\"2\">ConvNeXt-T/S/B/L ConvNeXt-T/S/B/L/XL ImageNet-1K ImageNet-22K</td></tr><tr><td></td><td>2242</td><td>2242</td></tr><tr><td>weightinit</td><td>trunc.normal (0.2)</td><td>trunc.normal (0.2)</td></tr><tr><td>optimizer</td><td>AdamW</td><td>AdamW</td></tr><tr><td>base learning rate</td><td>4e-3</td><td>4e-3</td></tr><tr><td>weight decay</td><td>0.05</td><td>0.05</td></tr><tr><td>optimizer momentum</td><td>β1,β2=0.9,0.999</td><td>β1,β2=0.9,0.999</td></tr><tr><td>batch size</td><td>4096</td><td>4096</td></tr><tr><td>training epochs</td><td>300</td><td>90</td></tr><tr><td>learning rate schedule</td><td>cosine decay</td><td>cosine decay</td></tr><tr><td>warmup epochs</td><td>20</td><td>5</td></tr><tr><td>warmup schedule</td><td>linear</td><td>linear</td></tr><tr><td>layer-wise lr decay [6,12]</td><td>None</td><td>None</td></tr><tr><td>randaugment [14]</td><td>(9,0.5)</td><td>(9,0.5)</td></tr><tr><td>mixup [90]</td><td>0.8</td><td>0.8</td></tr><tr><td>cutmix [89]</td><td>1.0</td><td>1.0</td></tr><tr><td>random erasing [91]</td><td>0.25</td><td>0.25</td></tr><tr><td>label smoothing [69]</td><td>0.1</td><td>0.1</td></tr><tr><td>stochastic depth [37]</td><td>0.1/0.4/0.5/0.5</td><td>0.0/0.0/0.1/0.1/0.2</td></tr><tr><td>layer scale [74]</td><td>1e-6</td><td>1e-6</td></tr><tr><td>head init scale [74]</td><td>None</td><td>None</td></tr><tr><td>gradient clip</td><td>None</td><td>None</td></tr><tr><td>exp.mov.avg.(EMA) [51]</td><td>0.9999</td><td>None</td></tr></table>",
        "bbox": [
            501,
            246,
            905,
            542
        ],
        "page_idx": 8
    },
    {
        "type": "text",
        "text": "A.2. ImageNet Fine-tuning ",
        "text_level": 1,
        "bbox": [
            503,
            631,
            709,
            647
        ],
        "page_idx": 8
    },
    {
        "type": "text",
        "text": "We list the settings for fine-tuning on ImageNet-1K in Table 6. The fine-tuning starts from the final model weights obtained in pre-training,without using the EMA weights, even if in pre-training EMA is used and EMA accuracy is reported. This is because we do not observe improvement if we fine-tune with the EMA weights (consistent with observations in [73]). The only exception is ConvNeXt-L pre-trained on ImageNet-1K, where the model accuracy is significantly lower than the EMA accuracy due to overfitting,and we select its best EMA model during pre-training as the starting point for fine-tuning. ",
        "bbox": [
            503,
            656,
            892,
            821
        ],
        "page_idx": 8
    },
    {
        "type": "text",
        "text": "In fine-tuning, we use layer-wise learning rate decay [6, 12] with every 3 consecutive blocks forming a group.When the model is fine-tuned at $3 8 4 ^ { 2 }$ resolution, we use a crop ratio of 1.0 (i.e., no cropping) during testing following [2,74,80], instead of 0.875 at $2 2 4 ^ { 2 }$ . ",
        "bbox": [
            503,
            825,
            892,
            900
        ],
        "page_idx": 8
    },
    {
        "type": "table",
        "img_path": "images/aa44665bc76b113bbea752c30a0b2526ff7ad0d0738d57cdbd425f728add220b.jpg",
        "table_caption": [
            "Table 6. ImageNet-1K fine-tuning setings. Multiple values (e.g., 0.8/0.95)are for each model (e.g., ConvNeXt-B/L) respectively. "
        ],
        "table_footnote": [],
        "table_body": "<table><tr><td>pre-training config</td><td>ConvNeXt-B/L ImageNet-1K 2242</td><td>ConvNeXt-T/S/B/L/XL ImageNet-22K 2242</td></tr><tr><td>fine-tuning config</td><td>ImageNet-1K 3842</td><td>ImageNet-1K 224² and 3842</td></tr><tr><td>optimizer</td><td>AdamW</td><td>AdamW</td></tr><tr><td>base learning rate</td><td>5e-5</td><td>5e-5</td></tr><tr><td>weight decay</td><td>1e-8</td><td>1e-8</td></tr><tr><td>optimizer momentum</td><td>β1,β2=0.9,0.999</td><td>β1,β2=0.9,0.999</td></tr><tr><td>batch size</td><td>512</td><td>512</td></tr><tr><td>training epochs</td><td>30</td><td>30</td></tr><tr><td>learning rate schedule layer-wise lr decay</td><td>cosine decay 0.7</td><td>cosine decay</td></tr><tr><td></td><td>None</td><td>0.8 None</td></tr><tr><td>warmup epochs</td><td>N/A</td><td></td></tr><tr><td>warmup schedule</td><td></td><td>N/A</td></tr><tr><td>randaugment</td><td>(9,0.5)</td><td>(9, 0.5)</td></tr><tr><td>mixup</td><td>None</td><td>None</td></tr><tr><td>cutmix</td><td>None</td><td>None</td></tr><tr><td>random erasing</td><td>0.25</td><td>0.25</td></tr><tr><td>label smoothing</td><td>0.1</td><td>0.1</td></tr><tr><td>stochastic depth</td><td>0.8/0.95</td><td>0.0/0.1/0.2/0.3/0.4</td></tr><tr><td>layer scale</td><td>pre-trained 0.001</td><td>pre-trained</td></tr><tr><td>head init scale</td><td></td><td>0.001</td></tr><tr><td>gradient clip</td><td>None</td><td>None</td></tr><tr><td>exp.mov.avg. (EMA)</td><td>None</td><td>None(T-L)/0.9999(XL)</td></tr></table>",
        "bbox": [
            78,
            88,
            472,
            397
        ],
        "page_idx": 9
    },
    {
        "type": "text",
        "text": "A.3.Downstream Tasks ",
        "text_level": 1,
        "bbox": [
            81,
            462,
            261,
            478
        ],
        "page_idx": 9
    },
    {
        "type": "text",
        "text": "For ADE20K and COCO experiments,we follow the training settings used in BEiT[6] and Swin [45]. We also use MMDetection [10] and MMSegmentation [13] toolboxes. We use the final model weights (instead of EMA weights) from ImageNet pre-training as network initializations. ",
        "bbox": [
            80,
            486,
            468,
            560
        ],
        "page_idx": 9
    },
    {
        "type": "text",
        "text": "We conduct a lightweight sweep for COCO experiments including learning rate {le-4,2e-4},layer-wise learning rate decay [6] {0.7, O.8, O.9, 0.95},and stochastic depth rate {0.3, 0.4, 0.5, 0.6, 0.7, O.8}. We fine-tune the ImageNet-22K pre-trained Swin-B/L on COCO using the same sweep. We use the official code and pre-trained model weights [3]. ",
        "bbox": [
            80,
            561,
            467,
            651
        ],
        "page_idx": 9
    },
    {
        "type": "text",
        "text": "The hyperparameters we sweep for ADE2OK experiments include learning rate {8e-5, le-4},layer-wise learning rate decay {0.8, 0.9},and stochastic depth rate {0.3, O.4, 0.5}. We report validation mIoU results using multi-scale testing. Additional single-scale testing results are in Table 7. ",
        "bbox": [
            81,
            652,
            468,
            727
        ],
        "page_idx": 9
    },
    {
        "type": "table",
        "img_path": "images/a3689456b5ccfb8ef2260c65d317660c9f520d47d364a04bd58a04e6cc74b29b.jpg",
        "table_caption": [
            "Table 7. ADE20K validation results with single-scale testing. "
        ],
        "table_footnote": [],
        "table_body": "<table><tr><td>backbone</td><td>input crop.</td><td>mIoU</td></tr><tr><td colspan=\"2\">ImageNet-1K pre-trained</td><td></td></tr><tr><td>ConvNeXt-T</td><td>512²</td><td>46.0</td></tr><tr><td>·ConvNeXt-S</td><td>5122</td><td>48.7</td></tr><tr><td>ConvNeXt-B .</td><td>5122</td><td>49.1</td></tr><tr><td colspan=\"3\">ImageNet-22K pre-trained</td></tr><tr><td>·ConvNeXt-B‡</td><td>640²</td><td>52.6</td></tr><tr><td>· ConvNeXt-L‡</td><td>640²</td><td>53.2</td></tr><tr><td></td><td></td><td></td></tr><tr><td>· ConvNeXt-XL‡</td><td>640²</td><td>53.6</td></tr></table>",
        "bbox": [
            151,
            739,
            397,
            871
        ],
        "page_idx": 9
    },
    {
        "type": "text",
        "text": "B. Robustness Evaluation ",
        "text_level": 1,
        "bbox": [
            503,
            89,
            717,
            106
        ],
        "page_idx": 9
    },
    {
        "type": "text",
        "text": "Additional robustness evaluation results for ConvNeXt models are presented in Table 8. We directly test our ImageNet-1K trained/fine-tuned classification models on several robustness benchmark datasets such as ImageNet-A [33], ImageNet-R [3O], ImageNet-Sketch [78] and ImageNetC/C [31,48] datasets. We report mean corruption error (mCE) for ImageNet-C,corruption error for ImageNet-C, and top-1 Accuracy for all other datasets. ",
        "bbox": [
            503,
            116,
            892,
            236
        ],
        "page_idx": 9
    },
    {
        "type": "text",
        "text": "ConvNeXt (in particular the large-scale model variants) exhibits promising robustness behaviors,outperforming state-of-the-art robust transformer models [47] on several benchmarks. With extra ImageNet-22K data, ConvNeXtXL demonstrates strong domain generalization capabilities (e.g. achieving $6 9 . 3 \\% / 6 8 . 2 \\% / 5 5 . 0 \\%$ accuracy on ImageNetA/R/Sketch benchmarks, respectively). We note that these robustness evaluation results were acquired without using any specialized modules or additional fine-tuning procedures. ",
        "bbox": [
            503,
            237,
            892,
            372
        ],
        "page_idx": 9
    },
    {
        "type": "table",
        "img_path": "images/86232cd640fad4ca492f88df11531d858906db6192ee8f10c288bf87949105db.jpg",
        "table_caption": [
            "Table 8.Robustness evaluation of ConvNeXt. We do not make use of any specialized modules or additional fine-tuning procedures. "
        ],
        "table_footnote": [],
        "table_body": "<table><tr><td>Model</td><td>Data/Size</td><td>FLOPs /Params</td><td>Clean</td><td>C(↓)</td><td>c(）</td><td>A</td><td>R</td><td>SK</td></tr><tr><td>ResNet-50</td><td>1K/2242</td><td>4.1/25.6</td><td>76.1</td><td>76.7</td><td>57.7</td><td>0.0</td><td>36.1</td><td>24.1</td></tr><tr><td>Swin-T [45]</td><td>1K/2242</td><td>4.5 /28.3</td><td>81.2</td><td>62.0</td><td>-</td><td>21.6</td><td>41.3</td><td>29.1</td></tr><tr><td>RVT-S*[47]</td><td>1K/2242</td><td>4.7 /23.3</td><td>81.9</td><td>49.4</td><td>37.5</td><td>25.7</td><td>47.7</td><td>34.7</td></tr><tr><td>ConvNeXt-T</td><td>1K/2242</td><td>4.5 / 28.6</td><td>82.1</td><td>53.2</td><td>40.0</td><td>24.2</td><td>47.2</td><td>33.8</td></tr><tr><td>Swin-B [45]</td><td>1K/2242</td><td>15.4 / 87.8</td><td>83.4</td><td>54.4</td><td>-</td><td>35.8</td><td>46.6</td><td>32.4</td></tr><tr><td>RVT-B* [47]</td><td>1K/2242</td><td>17.7 /91.8</td><td>82.6</td><td>46.8</td><td>30.8</td><td>28.5</td><td>48.7</td><td>36.0</td></tr><tr><td>ConvNeXt-B</td><td>1K/224²</td><td>15.4 / 88.6</td><td>83.8</td><td>46.8</td><td>34.4</td><td>36.7</td><td>51.3</td><td>38.2</td></tr><tr><td>ConvNeXt-B</td><td>22K/3842</td><td>45.1/ 88.6</td><td>86.8</td><td>43.1</td><td>30.7</td><td>62.3</td><td>64.9</td><td>51.6</td></tr><tr><td>ConvNeXt-L</td><td>22K/3842</td><td>101.0 / 197.8</td><td>87.5</td><td>40.2</td><td>29.9</td><td>65.5</td><td>66.7</td><td>52.8</td></tr><tr><td>ConvNeXt-XL</td><td>22K/3842</td><td>179.0 / 350.2</td><td>87.8</td><td>38.8</td><td>27.1</td><td>69.3</td><td>68.2</td><td>55.0</td></tr></table>",
        "bbox": [
            504,
            386,
            893,
            530
        ],
        "page_idx": 9
    },
    {
        "type": "text",
        "text": "C. Modernizing ResNets: detailed results ",
        "text_level": 1,
        "bbox": [
            503,
            601,
            848,
            618
        ],
        "page_idx": 9
    },
    {
        "type": "text",
        "text": "Here we provide detailed tabulated results for the modernization experiments,at both ResNet-5O / Swin-T and ResNet-200 /Swin-B regimes. The ImageNet-1K top-1 accuracies and FLOPs for each step are shown in Table 10 and 11. ResNet-5O regime experiments are run with 3 random seeds. ",
        "bbox": [
            503,
            627,
            892,
            717
        ],
        "page_idx": 9
    },
    {
        "type": "text",
        "text": "For ResNet-2OO, the initial number of blocks at each stage is (3,24, 36,3). We change it to Swin-B's (3, 3, 27, 3) at the step of changing stage ratio. This drastically reduces the FLOPs,so at the same time,we also increase the width from 64 to 84 to keep the FLOPs at a similar level. After the step of adopting depthwise convolutions,we further increase the width to 128 (same as Swin-B's) as a separate step. ",
        "bbox": [
            503,
            718,
            890,
            824
        ],
        "page_idx": 9
    },
    {
        "type": "text",
        "text": "The observations on the ResNet-200 regime are mostly consistent with those on ResNet-5O as described in the main paper. One interesting difference is that inverting dimensions brings a larger improvement at ResNet-2OO regime than at ResNet-50 regime $( + 0 . 7 9 \\%$ vs. $+ 0 . 1 4 \\%$ ). The performance gained by increasing kernel size also seems to saturate at kernel size 5 instead of 7. Using fewer normalization layers also has a bigger gain compared with the ResNet-5O regime $+ 0 . 4 6 \\%$ vs. $+ 0 . 1 4 \\%$ ). ",
        "bbox": [
            503,
            825,
            892,
            900
        ],
        "page_idx": 9
    },
    {
        "type": "table",
        "img_path": "images/c11d9cf612c0893d6d46ef49bd46710225e397a37b6e2344395334aa4e3c40b3.jpg",
        "table_caption": [
            "Table 9.Detailed architecture specifications for ResNet-5O, ConvNeXt-T and Swin-T. "
        ],
        "table_footnote": [],
        "table_body": "<table><tr><td rowspan=1 colspan=1></td><td rowspan=1 colspan=1>output size</td><td rowspan=1 colspan=1>·ResNet-50</td><td rowspan=1 colspan=1>·ConvNeXt-T</td><td rowspan=1 colspan=5>○Swin-T</td></tr><tr><td rowspan=1 colspan=1>stem</td><td rowspan=1 colspan=1>56×56</td><td rowspan=1 colspan=1>7×7,64,stride 23×3 max pool, stride 2</td><td rowspan=1 colspan=1>4×4,96, stride 4</td><td rowspan=1 colspan=5>4×4,96, stride 4</td></tr><tr><td rowspan=2 colspan=1>res2</td><td rowspan=2 colspan=1>56×56</td><td rowspan=2 colspan=1>[1×1,64]3×3,64 ×3[1×1,256]</td><td rowspan=2 colspan=1>[d7×7,96]1×1,384×31×1,96</td><td rowspan=2 colspan=3>1×1,96×3MSA,w7×7,H=3,rel. pos.1×1,961×1,3841×1,96</td><td rowspan=1 colspan=2>1×1,96×3MSA,w7×7,H=3,rel. pos.1×1,96</td></tr><tr><td rowspan=1 colspan=2></td></tr><tr><td rowspan=2 colspan=1>res3</td><td rowspan=2 colspan=1>28×28</td><td rowspan=2 colspan=1>[1×1,128]3×3,128×4[1×1,512]</td><td rowspan=2 colspan=1>[d7×7,192]1×1,768 ×31×1,192</td><td rowspan=2 colspan=2></td><td rowspan=1 colspan=3>1×1,192×3MSA, w7×7,H=6,rel. pos.1×1,192</td></tr><tr><td rowspan=1 colspan=1>1×1,7681×1,192</td><td rowspan=1 colspan=2></td></tr><tr><td rowspan=2 colspan=1>res4</td><td rowspan=2 colspan=1>14×14</td><td rowspan=2 colspan=1>[1×1,256]3×3,256 ×6[1×1,1024]</td><td rowspan=2 colspan=1>[d7×7,384]1×1,1536×9[1×1,384</td><td rowspan=1 colspan=1></td><td rowspan=1 colspan=3>1×1,384×3MSA,w7×7,H=12,rel. pos.1×1,384</td><td rowspan=1 colspan=1>×6</td></tr><tr><td rowspan=1 colspan=2></td><td rowspan=1 colspan=1>1×1,15361×1,384</td><td rowspan=1 colspan=2></td></tr><tr><td rowspan=2 colspan=1>res5</td><td rowspan=2 colspan=1>7×7</td><td rowspan=2 colspan=1>1×1,512]3×3,512 ×3[1×1,2048]</td><td rowspan=2 colspan=1>[d7×7,768]1×1,3072×3[1×1,768]</td><td rowspan=1 colspan=1></td><td rowspan=1 colspan=3>1×1,768×3MSA, w7×7,H=24, rel. pos.1×1,768</td><td rowspan=1 colspan=1>×2</td></tr><tr><td rowspan=1 colspan=2></td><td rowspan=1 colspan=1>1×1,30721×1,768</td><td rowspan=1 colspan=2></td></tr><tr><td rowspan=1 colspan=1></td><td rowspan=1 colspan=1>FLOPs</td><td rowspan=1 colspan=1>4.1×109</td><td rowspan=1 colspan=1>4.5×109</td><td rowspan=1 colspan=4>4.5×109</td><td rowspan=1 colspan=1></td></tr><tr><td rowspan=1 colspan=1>#</td><td rowspan=1 colspan=1>#params.</td><td rowspan=1 colspan=1>25.6×106</td><td rowspan=1 colspan=1>28.6×106</td><td rowspan=1 colspan=5>28.3×106</td></tr></table>",
        "bbox": [
            192,
            111,
            777,
            438
        ],
        "page_idx": 10
    },
    {
        "type": "table",
        "img_path": "images/13017815504e8a7fa746efac3edc8a8f6a5f0f956c8f276bf04e2c9832bf2adb.jpg",
        "table_caption": [
            "Table 10.Detailed results for modernizing a ResNet-50.Mean and standard deviation are obtained by training the network with three different random seeds. "
        ],
        "table_footnote": [],
        "table_body": "<table><tr><td>model</td><td>IN-1K acc.</td><td>GFLOPs</td></tr><tr><td>ResNet-50 (PyTorch [1])</td><td>76.13</td><td>4.09</td></tr><tr><td>ResNet-50 (enhanced recipe)</td><td>78.82 ± 0.07</td><td>4.09 4.53</td></tr><tr><td>stage ratio “patchify” stem</td><td>79.36 ± 0.07 79.51 ± 0.18</td><td>4.42</td></tr><tr><td>depthwise conv</td><td>78.28 ± 0.08</td><td>2.35</td></tr><tr><td>increase width</td><td>80.50 ± 0.02</td><td>5.27</td></tr><tr><td>inverting dimensions</td><td>80.64 ± 0.03</td><td>4.64</td></tr><tr><td>move up depthwise conv</td><td>79.92 ± 0.08</td><td>4.07</td></tr><tr><td>kernel size →5</td><td>80.35 ± 0.08</td><td>4.10</td></tr><tr><td>kernel size →7</td><td>80.57 ± 0.14</td><td>4.15</td></tr><tr><td>kernel size →9</td><td>80.57 ± 0.06</td><td>4.21</td></tr><tr><td>kernel size → 11</td><td>80.47 ± 0.11</td><td>4.29</td></tr><tr><td>ReLU→GELU</td><td>80.62 ± 0.14</td><td>4.15</td></tr><tr><td>fewer activations</td><td>81.27 ± 0.06</td><td>4.15</td></tr><tr><td>fewer norms</td><td>81.41 ± 0.09</td><td></td></tr><tr><td>BN→LN</td><td>81.47 ± 0.09</td><td>4.15 4.46</td></tr><tr><td> separate d.s. conv (ConvNeXt-T)</td><td>81.97 ± 0.06</td><td>4.49</td></tr><tr><td> Swin-T [45]</td><td>81.30</td><td>4.50</td></tr></table>",
        "bbox": [
            78,
            486,
            470,
            753
        ],
        "page_idx": 10
    },
    {
        "type": "text",
        "text": "",
        "bbox": [
            78,
            840,
            467,
            900
        ],
        "page_idx": 10
    },
    {
        "type": "table",
        "img_path": "images/260767020852f4768560f15e54d842f6340ecce345897ffa6a9446ae7a4896e0.jpg",
        "table_caption": [
            "Table 11. Detailed results for modernizing a ResNet-200. "
        ],
        "table_footnote": [],
        "table_body": "<table><tr><td>model</td><td>IN-1K acc.</td><td>GFLOPs</td></tr><tr><td>ResNet-200 [29]</td><td>78.20</td><td>15.01</td></tr><tr><td>ResNet-200 (enhanced recipe)</td><td>81.14</td><td>15.01</td></tr><tr><td>stage ratio and increase width</td><td>81.33</td><td>14.52</td></tr><tr><td>&quot;patchify” stem</td><td>81.59</td><td>14.38</td></tr><tr><td>depthwise conv</td><td>80.54</td><td>7.23</td></tr><tr><td>increase width</td><td>81.85</td><td>16.76</td></tr><tr><td>inverting dimensions</td><td>82.64</td><td>15.68</td></tr><tr><td>move up depthwise conv</td><td>82.04</td><td>14.63</td></tr><tr><td>kernel size →5</td><td>82.32</td><td>14.70</td></tr><tr><td>kernel size →7</td><td>82.30</td><td>14.81</td></tr><tr><td>kernel size → 9</td><td>82.27</td><td>14.95</td></tr><tr><td>kernel size →11</td><td>82.18</td><td>15.13</td></tr><tr><td>ReLU→GELU</td><td>82.19</td><td>14.81</td></tr><tr><td>fewer activations</td><td>82.71</td><td>14.81</td></tr><tr><td>fewer norms</td><td>83.17</td><td>14.81</td></tr><tr><td>BN→LN</td><td>83.35</td><td>14.81</td></tr><tr><td> separate d.s. conv (ConvNeXt-B)</td><td>83.60</td><td>15.35</td></tr><tr><td>Swin-B [45]</td><td>83.50</td><td>15.43</td></tr></table>",
        "bbox": [
            500,
            486,
            892,
            753
        ],
        "page_idx": 10
    },
    {
        "type": "text",
        "text": "D. Detailed Architectures ",
        "text_level": 1,
        "bbox": [
            503,
            810,
            715,
            828
        ],
        "page_idx": 10
    },
    {
        "type": "text",
        "text": "We present a detailed architecture comparison between ResNet-50, ConvNeXt-T and Swin-T in Table 9. For differently sized ConvNeXts,only the number of blocks and the number of channels at each stage differ from ConvNeXt-T (see Section 3 for details). ConvNeXts enjoy the simplicity of standard ConvNets,but compete favorably with Swin Transformers in visual recognition. ",
        "bbox": [
            501,
            840,
            892,
            900
        ],
        "page_idx": 10
    },
    {
        "type": "text",
        "text": "",
        "bbox": [
            78,
            92,
            468,
            136
        ],
        "page_idx": 11
    },
    {
        "type": "text",
        "text": "E. Benchmarking on A100 GPUs ",
        "text_level": 1,
        "bbox": [
            81,
            148,
            354,
            166
        ],
        "page_idx": 11
    },
    {
        "type": "text",
        "text": "Following Swin Transformer [45], the ImageNet models' inference throughputs in Table 1 are benchmarked using a V100 GPU, where ConvNeXt is slightly faster in inference than Swin Transformer with a similar number of parameters. We now benchmark them on the more advanced A1Oo GPUs, which support the TensorFloat32(TF32) tensor cores.We employ PyTorch [5O] version 1.1O to use the latest “Channel Last’ memory layout [22] for further speedup. ",
        "bbox": [
            80,
            175,
            468,
            295
        ],
        "page_idx": 11
    },
    {
        "type": "text",
        "text": "We present the results in Table 12. Swin Transformers and ConvNeXts both achieve faster inference throughput than V100 GPUs, but ConvNeXts’ advantage is now significantly greater, sometimes up to $49 \\%$ faster. This preliminary study shows promising signals that ConvNeXt,employed with standard ConvNet modules and simple in design, could be practically more efficient models on modern hardwares. ",
        "bbox": [
            80,
            296,
            467,
            401
        ],
        "page_idx": 11
    },
    {
        "type": "table",
        "img_path": "images/7e4765de86fe6ec22a7c6a534b1328ed10e628355e1f1737c8ffc13ebfb96600.jpg",
        "table_caption": [
            "Table 12. Inference throughput comparisons on an A1oo GPU. Using TF32 data format and “channel last”memory layout, ConvNeXt enjoys up to ${ \\sim } 4 9 \\%$ higher throughput compared with a Swin Transformer with similar FLOPs. "
        ],
        "table_footnote": [],
        "table_body": "<table><tr><td>model</td><td>image size</td><td>FLOPs</td><td>throughput (image / s)</td><td>IN-1K/22K trained,1K acc.</td></tr><tr><td>Swin-T</td><td>2242</td><td>4.5G</td><td>1325.6</td><td>81.3/</td></tr><tr><td>· ConvNeXt-T</td><td>224²</td><td>4.5G</td><td>1943.5 (+47%)</td><td>82.1 /</td></tr><tr><td>○ Swin-S</td><td>224²</td><td>8.7G</td><td>857.3</td><td>83.0/ 1</td></tr><tr><td>· ConvNeXt-S</td><td>224²</td><td>8.7G</td><td>1275.3 (+49%)</td><td>83.1 /</td></tr><tr><td>Swin-B</td><td>224²</td><td>15.4G</td><td>662.8</td><td>83.5 / 85.2</td></tr><tr><td> ConvNeXt-B</td><td>224²</td><td>15.4G</td><td>G969.0 (+46%)</td><td>83.8 / 85.8</td></tr><tr><td>Swin-B</td><td>384²</td><td>47.1G</td><td>242.5</td><td>84.5 / 86.4</td></tr><tr><td>· ConvNeXt-B</td><td>384²</td><td>45.0G</td><td>336.6 (+39%)</td><td>85.1 / 86.8</td></tr><tr><td> Swin-L</td><td>224²</td><td>34.5G</td><td>435.9</td><td>/86.3</td></tr><tr><td>· ConvNeXt-L</td><td>224²</td><td>34.4G</td><td>611.5 (+40%)</td><td>84.3 / 86.6</td></tr><tr><td>○ Swin-L</td><td>384²</td><td>103.9G</td><td>157.9</td><td>- /87.3</td></tr><tr><td>·ConvNeXt-L</td><td>3842</td><td>101.0G</td><td>211.4 (+34%)</td><td>85.5 / 87.5</td></tr><tr><td>· ConvNeXt-XL</td><td>224²</td><td>60.9G</td><td>424.4</td><td>- /87.0</td></tr><tr><td>· ConvNeXt-XL</td><td>384²</td><td>179.0G</td><td>147.4</td><td>- /87.8</td></tr></table>",
        "bbox": [
            81,
            419,
            478,
            643
        ],
        "page_idx": 11
    },
    {
        "type": "text",
        "text": "F. Limitations ",
        "text_level": 1,
        "bbox": [
            80,
            738,
            199,
            756
        ],
        "page_idx": 11
    },
    {
        "type": "text",
        "text": "We demonstrate ConvNeXt, a pure ConvNet model, can perform as good as a hierarchical vision Transformer on image classification,object detection,instance and semantic segmentation tasks. While our goal is to offer a broad range of evaluation tasks,we recognize computer vision applications are even more diverse.ConvNeXt may be more suited for certain tasks,while Transformers may be more flexible for others.A case in point is multi-modal learning,in which a cross-attention module may be preferable for modeling feature interactions across many modalities. Additionally, Transformers may be more flexible when used for tasks requiring discretized,sparse,or structured outputs.We believe the architecture choice should meet the needs of the task at hand while striving for simplicity. ",
        "bbox": [
            80,
            765,
            468,
            900
        ],
        "page_idx": 11
    },
    {
        "type": "text",
        "text": "",
        "bbox": [
            503,
            92,
            892,
            166
        ],
        "page_idx": 11
    },
    {
        "type": "text",
        "text": "G. Societal Impact ",
        "text_level": 1,
        "bbox": [
            503,
            181,
            658,
            199
        ],
        "page_idx": 11
    },
    {
        "type": "text",
        "text": "In the 2O2Os,research on visual representation learning began to place enormous demands on computing resources. While larger models and datasets improve performance across the board, they also introduce a slew of challenges.ViT, Swin,and ConvNeXt all perform best with their huge model variants. Investigating those model designs inevitably results in an increase in carbon emissions.One important direction,and a motivation for our paper, is to strive for simplicity — with more sophisticated modules, the network's design space expands enormously, obscuring critical components that contribute to the performance difference.Additionally,large models and datasets present issues in terms of model robustness and fairness.Further investigation on the robustness behavior of ConvNeXt vs. Transformer will be an interesting research direction. In terms of data, our findings indicate that ConvNeXt models benefit from pre-training on large-scale datasets.While our method makes use of the publicly available ImageNet-22K dataset, individuals may wish to acquire their own data for pre-training.A more circumspect and responsible approach to data selection is required to avoid potential concerns with data biases. ",
        "bbox": [
            503,
            208,
            892,
            539
        ],
        "page_idx": 11
    },
    {
        "type": "text",
        "text": "References ",
        "text_level": 1,
        "bbox": [
            503,
            555,
            594,
            571
        ],
        "page_idx": 11
    },
    {
        "type": "text",
        "text": "[1] PyTorch Vision Models. https ://pytorch.org / vision/stable/models .html. Accessed: 2021-10- 01.   \n[2] GitHub repository: Swin transformer. https ://github. com/microsoft/Swin-Transformer,2021.   \n[3] GitHub repository:Swin transformer for object detection. https://github.com/SwinTransformer/SwinTransformer-Object-Detection,2021.   \n[4] Anonymous.Patches are all you need? Openreview,2021.   \n[5] Jimmy Lei Ba,Jamie Ryan Kiros,and Geoffrey E Hinton. Layer normalization. arXiv:1607.06450,2016.   \n[6] Hangbo Bao,Li Dong,and Furu Wei.BEiT:BERT pretraining of image transformers.arXiv:2106.08254,2021.   \n[7] Irwan Bello,William Fedus,Xianzhi Du,Ekin Dogus Cubuk, Aravind Srinivas,Tsung-YiLin, Jonathon Shlens,and Barret Zoph.Revisiting resnets: Improved training and scaling strategies.NeurIPS,2021.   \n[8] Irwan Bello,Barret Zoph,Ashish Vaswani, Jonathon Shlens, and Quoc VLe.Attention augmented convolutional networks. In ICCV,2019.   \n[9] Zhaowei Cai and Nuno Vasconcelos. Cascade R-CNN: Delving into high quality object detection.In CVPR,2018.   \n[10] Kai Chen, Jiaqi Wang,Jiangmiao Pang,Yuhang Cao,Yu Xiong, Xiaoxiao Li, Shuyang Sun,Wansen Feng, Ziwei Liu, Jiarui Xu, Zheng Zhang,Dazhi Cheng,Chenchen Zhu, Tianheng Cheng,Qijie Zhao, Buyu Li, Xin Lu, Rui Zhu, Yue Wu,Jifeng Dai,Jingdong Wang, Jianping Shi, Wanli Ouyang, Chen Change Loy,and Dahua Lin. MMDetection: Open mmlab detection toolbox and benchmark.arXiv:1906.07155, 2019.   \n[11] Frangois Chollet. Xception: Deep learning with depthwise separable convolutions. In CVPR,2017.   \n[12] Kevin Clark,Minh-Thang Luong, Quoc VLe,and Christopher D Manning. ELECTRA: Pre-training text encoders as discriminators rather than generators.In ICLR,2020.   \n[13] MMSegmentation contributors.MMSegmentation: Openmmlab semantic segmentation toolbox and benchmark. ht tp s : / /github.com/open-mmlab/mmsegmentation, 2020.   \n[14] Ekin D Cubuk,Barret Zoph,Jonathon Shlens,and Quoc V Le.Randaugment: Practical automated data augmentation with a reduced search space.In CVPR Workshops,2020.   \n[15] Zihang Dai, Hanxiao Liu, Quoc V Le,and Mingxing Tan. Coatnet: Marrying convolution and attention for all data sizes. NeurIPS,2021.   \n[16] Stéphane d'Ascoli,Hugo Touvron,Matthew Leavitt, Ari Morcos, Giulio Biroli, and Levent Sagun. ConViT: Improving vision transformers with soft convolutional inductive biases. ICML,2021.   \n[17] Jia Deng,Wei Dong,Richard Socher,Li-JiaLi, Kai Li,and Li Fei-Fei. ImageNet:A large-scale hierarchical image database. In CVPR,2009.   \n[18] Jacob Devlin,Ming-Wei Chang,Kenton Lee,and Kristina Toutanova. BERT: Pre-training of deep bidirectional transformers for language understanding. In NAACL, 2019.   \n[19] Piotr Dollar, Serge Belongie,and Pietro Perona.The fastest pedestrian detector in the west. In BMVC,2010.   \n[20] Alexey Dosovitskiy,Lucas Beyer,Alexander Kolesnikov, Dirk Weissenborn，Xiaohua Zhai,Thomas Unterthiner, Mostafa Dehghani,Matthias Minderer, Georg Heigold, Sylvain Gelly,Jakob Uszkoreit,and Neil Houlsby. An image is worth 16x16 words: Transformers for image recognition at scale. In ICLR,2021.   \n[21] Haoqi Fan,Bo Xiong, Kartikeya Mangalam, Yanghao Li, Zhicheng Yan,Jitendra Malik,and Christoph Feichtenhofer. Multiscale vision transformers.ICCV,2021.   \n[22] Vitaly Fedyunin． Tutorial: Channel last memory format in PyTorch. https://pytorch.org/tutorials/ intermediate/memory_format_tutorial.html, 2021. Accessed: 2021-10-01.   \n[23] Ross Girshick. Fast R-CNN. In ICCV,2015.   \n[24] Ross Girshick,Jeff Donahue,Trevor Darrell,and Jitendra Malik.Rich feature hierarchies for accurate object detection and semantic segmentation.In CVPR,2014.   \n[25] Qi Han, Zejia Fan,Qi Dai, Lei Sun,Ming-Ming Cheng, Jiaying Liu,and Jingdong Wang.Demystifying local vision transformer: Sparse connectivity,weight sharing,and dynomic w0iaht aVi..2106 n4262 2001   \n[26] Kaiming He, Xinlei Chen, Saining Xie, Yanghao Li, Piotr Dollar,and Ross Girshick. Masked autoencoders are scalable vision learners.arXiv:2111.06377,2021.   \n[27] Kaiming He,Georgia Gkioxari, Piotr Dollar,and Ross Girshick.Mask R-CNN. In ICCV,2017.   \n[28] Kaiming He, Xiangyu Zhang, Shaoqing Ren,and Jian Sun. Deep residual learning for image recognition. In CVPR,2016.   \n[29] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Identity mappings in deep residual networks. In ECCV, 2016.   \n[30] Dan Hendrycks, Steven Basart,Norman Mu, Saurav Kadavath,Frank Wang,Evan Dorundo, Rahul Desai, Tyler Zhu, Samyak Parajuli,Mike Guo, et al. The many faces of robustness: A critical analysis of out-of-distribution generalization. In ICCV, 2021.   \n[31] Dan Hendrycks and Thomas Dietterich. Benchmarking neural network robustness to common corruptions and perturbations. In ICLR,2018.   \n[32] Dan Hendrycks and Kevin Gimpel. Gaussian error linear units (gelus).arXiv:1606.08415,2016.   \n[33] Dan Hendrycks,Kevin Zhao, Steven Basart, Jacob Steinhardt, and Dawn Song.Natural adversarial examples.In CVPR, 2021.   \n[34] Andrew G Howard,Menglong Zhu，Bo Chen， Dmitry Kalenichenko, Weijun Wang, Tobias Weyand, Marco Andreetto,and Hartwig Adam．MobileNets:Efficient convolutional neural networks for mobile vision applications. arXiv:1704.04861,2017.   \n[35] Jie Hu,Li Shen,and Gang Sun. Squeeze-and-excitation networks.In CVPR,2018.   \n[36] Gao Huang, Zhuang Liu, Laurens van der Maaten, and Kilian Q Weinberger. Densely connected convolutional networks. In CVPR,2017.   \n[37] Gao Huang, Yu Sun, Zhuang Liu, Daniel Sedra,and Kilian Q Weinberger. Deep networks with stochastic depth. In ECCV, 2016.   \n[38] Sergey Ioffe. Batch renormalization: Towards reducing minibatch dependence in batch-normalized models. In NeurIPS, 2017.   \n[39] Alexander Kolesnikov,Lucas Beyer,Xiaohua Zhai,Joan Puigcerver, Jessica Yung,Sylvain Gelly,and Neil Houlsby. Big Transfer (BiT): General visual representation learning. In ECCV,2020.   \n[40]Alex Krizhevsky, Ilya Sutskever,and Geoff Hinton.Imagenet classification with deep convolutional neural networks.In NeurIPS,2012.   \n[41] Andrew Lavin and Scott Gray. Fast algorithms for convolutional neural networks.In CVPR,2016.   \n[42] Yann LeCun,Bernhard Boser,John S Denker,Donnie Henderson,Richard E Howard,Wayne Hubbard,and Lawrence D Jackel.Backpropagation applied to handwritten zip code recognition.Neural computation,1989.   \n[43] Yann LeCun,Leon Bottou, Yoshua Bengio,Patrick Haffner, et al. Gradient-based learning applied to document recognition.Proceedings of the IEEE,1998.   \n[44] Tsung-Yi Lin,Michael Maire, Serge Belongie, James Hays, Pietro Perona, Deva Ramanan,Piotr Dollar,and C Lawrence Zitnick. Microsoft COCO: Common objects in context. In   \n[45] Ze Liu, Yutong Lin, Yue Cao, Han Hu, Yixuan wel, ∠neng Zhang,Stephen Lin,and Baining Guo. Swin transformer: Hierarchical vision transformer using shifted windows.2021.   \n[46] Ilya Loshchilov and Frank Huter. Decoupled weight decay regularization. In ICLR,2019.   \n[47] Xiaofeng Mao, Gege Qi, Yuefeng Chen, Xiaodan Li, Ranjie Duan,Shaokai Ye,Yuan He,and Hui Xue.Towards robust vision transformer. arXiv preprint arXiv:2105.07926,2021.   \n[48] Eric Mintun,Alexander Kirillov,and Saining Xie.On interaction between augmentations and corruptions in natural corruption robustness.NeurIPS,2021.   \n[49]Vinod Nair and Geoffrey E Hinton．Rectified linear units improve restricted boltzmann machines.In ICML,2010.   \n[50] Adam Paszke, Sam Gross, Francisco Massa, Adam Lerer, James Bradbury, Gregory Chanan, Trevor Killen, Zeming Lin,Natalia Gimelshein,Luca Antiga,et al.PyTorch: An imperative style, high-performance deep learning library. In NeurIPS,2019.   \n[51] Boris T Polyak and Anatoli B Juditsky.Acceleration of stochastic approximation by averaging. SIAM Journal on Control and Optimization,1992.   \n[52] Alec Radford,Jeffrey Wu,Rewon Child,David Luan,Dario Amodei, and Ilya Sutskever. Language models are unsupervised multitask learners. 2019.   \n[53] Ilija Radosavovic, Justin Johnson, Saining Xie,Wan-Yen Lo,and Piotr Dollar. On network design spaces for visual recognition. In ICCV,2019.   \n[54]Ilija Radosavovic,Raj Prateek Kosaraju,Ross Girshick,Kaiming He,and Piotr Dollar. Designing network design spaces. In CVPR,2020.   \n[55] Prajit Ramachandran,Niki Parmar, Ashish Vaswani, Irwan Bello,Anselm Levskaya,and Jonathon Shlens. Stand-alone self-attention in vision models.NeurIPS,2019.   \n[56] Yongming Rao,Wenliang Zhao, Zheng Zhu, Jiwen Lu,and Jie Zhou. Global filter networks for image classification. NeurIPS,2021.   \n[57] Shaoqing Ren, Kaiming He,Ross Girshick,and Jian Sun. Faster R-CNN: Towards real-time object detection with region proposal networks. In NeurIPS,2015.   \n[58] Henry A Rowley, Shumeet Baluja,and Takeo Kanade. Neural network-based face detection.TPAMI,1998.   \n[59] Olga Russakovsky,Jia Deng,Hao Su,Jonathan Krause, Sanjeev Satheesh, Sean Ma, Zhiheng Huang,Andrej Karpathy, Aditya Khosla,Michael Bernstein,Alexander C.Berg,and Li Fei-Fei. ImageNet Large Scale Visual Recognition Challenge. IJCV, 2015.   \n[60] Tim Salimans and Diederik P Kingma. Weight normalization: A simple reparameterization to accelerate training of deep neural networks. In NeurIPS,2016.   \n[61]Mark Sandler,Andrew Howard,Menglong Zhu,Andrey Zhmoginov,and Liang-Chieh Chen.Mobilenetv2: Inverted residualsandlinearbottlenecks.In CVPR,2018.   \n[62] Pierre Sermanet,David Eigen, Xiang Zhang,Michael Mathieu,Rob Fergus,and Yann LeCun. Overfeat: Integrated recognition,localization and detection using convolutional networks In ICIR 2014   \n[63] Pierre Sermanet, Koray Kavukcuoglu, Soumith Chintala,and Yann LeCun. Pedestrian detection with unsupervised multistage feature learning. In CVPR, 2013.   \n[64] Karen Simonyan and Andrew Zisserman. Two-stream convolutional networks for action recognition in videos.In NeurIPS, 2014.   \n[65] Karen Simonyan and Andrew Zisserman. Very deep convolutional networks for large-scale image recognition. In ICLR, 2015.   \n[66] Aravind Srinivas,Tsung-Yi Lin,Niki Parmar,Jonathon Shlens,Pieter Abbeel,and Ashish Vaswani.Botleneck transformers for visual recognition. In CVPR,2021.   \n[67] Andreas Steiner,Alexander Kolesnikov, Xiaohua Zhai, Ross Wightman,Jakob Uszkoreit,and Lucas Beyer. How to train your vit? data,augmentation,and regularization in vision transformers. arXiv preprint arXiv:2106.10270,2021.   \n[68] Christian Szegedy,Wei Liu, Yangqing Jia,Pierre Sermanet, Scott Reed, Dragomir Anguelov, Dumitru Erhan, Vincent Vanhoucke,and Andrew Rabinovich. Going deper with convolutions. In CVPR, 2015.   \n[69] Christian Szegedy，Vincent Vanhoucke， Sergey Ioffe, Jonathon Shlens,and Zbigniew Wojna. Rethinking the inception architecture for computer vision. In CVPR,2016.   \n[70] Mingxing Tan, Bo Chen,Ruoming Pang, Vijay Vasudevan, Mark Sandler,Andrew Howard,and Quoc VLe.Mnasnet: Platform-aware neural architecture search for mobile. In CVPR,2019.   \n[71] Mingxing Tan and Quoc Le. Efficientnet: Rethinking model scaling for convolutional neural networks.In ICML,2019.   \n[72] Mingxing Tan and Quoc Le. Efficientnetv2: Smaller models and faster training.In ICML,2021.   \n[73] Hugo Touvron,Matthieu Cord,Matthijs Douze,Francisco Mass, Alexandre Sablayrolles, and Herve Jegou. Training data-eficient image transformers & distillation through attention. arXiv:2012.12877,2020.   \n[74] Hugo Touvron，Matthieu Cord，Alexandre Sablayrolles, Gabriel Synnaeve,and Hervé Jégou. Going deeper with image transformers. ICCV,2021.   \n[75] Dmitry Ulyanov,Andrea Vedaldi,and Victor Lempitsky. Instance normalization: The missing ingredient for fast stylization. arXiv:1607.08022,2016.   \n[76] Régis Vaillant, Christophe Monrocq,and YannLe Cun. Original approach for the localisation of objects in images. Vision, Image and Signal Processing,1994.   \n[77] Ashish Vaswani,Noam Shazeer, Niki Parmar, Jakob Uszkoreit,Llion Jones,Aidan N Gomez,Lukasz Kaiser,and Illia Polosukhin. Attention is all you need. In NeurIPS,2017.   \n[78] Haohan Wang, Songwei Ge, Eric P Xing,and Zachary C Lipton. Learning robust global representations by penalizing local predictive power. NeurIPS,2019.   \n[79] Xiaolong Wang, Ross Girshick, Abhinav Gupta,and Kaiming He.Non-local neural networks. In CVPR,2018.   \n[80] Ross Wightman. GitHub repository: Pytorch image models. https://github.com/rwightman/pytorchimage-models,2019.   \n[81] Ross Wightman, Hugo Touvron, and Hervé Jégou. Resnet strikes back:An improved training procedure in timm. arXiv:2110 00476 202.1   \n[82] Haiping Wu, Bin Xiao,Noel Codella, Mengchen Liu, Xiyang Dai,Lu Yuan,and Lei Zhang. Cvt: Introducing convolutions to vision transformers.ICCV,2021.   \n[83] Yuxin Wu and Kaiming He. Group normalization. In ECCV, 2018.   \n[84] Yuxin Wu and Justin Johnson.Rethinking \"batch\"in batchnorm.arXiv:2105.07576,2021.   \n[85] Tete Xiao, Yingcheng Liu,Bolei Zhou, Yuning Jiang,and Jian Sun. Unified perceptual parsing for scene understanding. In ECCV,2018.   \n[86] Tete Xiao,Mannat Singh,Eric Mintun, Trevor Darrell,Piotr Dollar,and Ross Girshick.Early convolutions help transformers see better.In NeurIPS,2021.   \n[87] Saining Xie,Ross Girshick,Piotr Dollar, Zhuowen Tu, and Kaiming He. Aggregated residual transformations for deep neural networks. In CVPR,2017.   \n[88] Weijian Xu, Yifan Xu,Tyler Chang,and Zhuowen Tu. Coscale conv-attentional image transformers.ICCV,2021.   \n[89] Sangdoo Yun,Dongyoon Han, Seong Joon Oh, Sanghyuk Chun, Junsuk Choe,and Youngjoon Yoo. Cutmix:Regularization strategy to train strong classifiers with localizable features.In ICCV,2019.   \n[90] Hongyi Zhang,Moustapha Cisse, Yann N Dauphin,and David Lopez-Paz. mixup: Beyond empirical risk minimization. In ICLR,2018.   \n[91] Zhun Zhong,Liang Zheng,Guoliang Kang, Shaozi Li,and Yi Yang. Random erasing data augmentation.In AAAI, 2020.   \n[92] Bolei Zhou,Hang Zhao,Xavier Puig,Tete Xiao, Sanja Fidler, Adela Barriuso,and Antonio Torralba. Semantic understanding of scenes through the ADE2OK dataset. IJCV,2019. ",
        "bbox": [
            508,
            580,
            893,
            900
        ],
        "page_idx": 11
    },
    {
        "type": "text",
        "text": "",
        "bbox": [
            76,
            88,
            472,
            893
        ],
        "page_idx": 12
    },
    {
        "type": "text",
        "text": "",
        "bbox": [
            501,
            94,
            893,
            892
        ],
        "page_idx": 12
    },
    {
        "type": "text",
        "text": "",
        "bbox": [
            76,
            98,
            472,
            895
        ],
        "page_idx": 13
    },
    {
        "type": "text",
        "text": "",
        "bbox": [
            500,
            92,
            892,
            895
        ],
        "page_idx": 13
    },
    {
        "type": "text",
        "text": "",
        "bbox": [
            78,
            92,
            470,
            520
        ],
        "page_idx": 14
    }
]